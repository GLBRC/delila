/* Output from p2c 2.00.Oct.15, the Pascal-to-C translator */
/* From input file "ri.p" */

/* ri: Rindividual is calculated for every site in the aligned book

  Thomas D. Schneider, Ph.D.
  toms@alum.mit.edu
  https://alum.mit.edu/www/toms

module libraries required: delman, prgmod, delmod *)

2013 Jun 06, 2.82: min/maxribl increased
2012 Jan 18, 2.81: maxribl increased
2012 Jan 18, 2.80: maximumrange increased by getting new delmod modules
2008 Apr 24, 2.79: reported value of neginfinity should have same wid/dec as table
2008 Apr 20, 2.78: niot must be real for precise computations
2005 Sep 28, 2.77: protect ln(x) from x <= 0.
2005 Sep 28, 2.76: lock unused modules
2005 May 23, 2.75: add patent message
2004 Dec 15, 2.74: update documentation of new parameters
2004 Dec 15, 2.73: prgmod module readheader upgraded.  cleanup.
2004 Dec 15, 2.72: crash on reading hold file using gpc compiler
2003 Aug 18, 2.71: niot is used when nxl < 1.
2003 Aug 18, 2.70: niot should accept -1000.
                   Ricalc: in this case compute appropriately.
2002 Aug 19, 2.69: add standard deviation computation to rixyin output EXPERIMENTAL
2002 Jun 21, 2.68: reported consensus range was wrong - corrected in prgmod.
2002 Apr 19, 2.67: documentation upgrade
2001 May 10, 2.65: BUG in Ri(bl) found and corrected!
2000 Dec 13, 2.64: upgrade alignment from delmod
2000 Dec 13, 2.63: upgrade See Also documentation
2000 Jul 30, 2.62: upgrade to GPC
2000 Jun 19, 2.59: fix symmetry detection in matrixsymmetry
1999 Oct  6, 2.55: now creates riinst file
1999 Jul  9, 2.53: automatic upgrade from rip 2.33 to 2.53
1999 Jul  5, 2.49: name and bounds in rip, standard routines from prgmod.p
1999 Jun  1, 2.47: upgrade to theline stuff for aligned list
1999 Mar 11, 2.44: attach wave definition to end of ribl 
1998 Oct 19, ----: range set to 1000
1997 Apr 17, 2.33: ribl now contains n(b,l) to allow detection of
    negative infinities (zero cases) by later programs (and whatever).
1995 Aug 29:  Standard deviation should be calculated from n-1.
origin 1990 Aug 15 from Dalvec 1.05 *)
updateversion = 2.53; (* defines lowest acceptable current parameter file *)

name
   ri: Rindividual is calculated for every site in the aligned book

synopsis
   ri(inst: in, book: in, rsdata: in, values: in, rip: in, wave: in,
      rixyin: out, sequ: out, ribl: out, riinst: out, output: out)

files
   inst: delila instructions of the form 'get from 56 -5 to 56 +10;'
      (This file may be empty, in which case the sequences will be
      aligned by their 5' ends.)

   book: the book generated by delila using inst

   rsdata: data file from rseq program

   values: a file containing the values of the objects to which the Ri
      values are to be compared.  The file may be empty.  The file
      can contain some values and then terminate.  Further values
      will be assumed to be zero.  This allows one to copy a rixyin file
      produced by ri in to the values file.  Then one adds a new site
      runs delila etc and when ri runs again it will get the old values
      lined up to the new values, with zero for the one that was
      not there previously.
rip:  Parameters to control the program.  The file must contain the
      following parameters, one per line:

      * parameterversion:  The version number of the program.  This allows
        the user to be warned if an old parameter file is used.

      * name (string in quotes): The name of the weight matrix.

      * thefrom, theto (integers): The FROM and TO over which to do the Ri
        calculation.  These must not exceed either of those in the inst/book
        or the rsdata.  The FROM value must be less than or equal to the TO
        value.

      * column (integer): defines the column of the values file to use.

      * lowerRi, upperRi (two reals): the lowest and highest Ri evaluation to
        report to rixyin, sequ and riinst.  If the first character of the
        line is 'a' then all evaluations are reported.  Otherwise two real
        numbers are expected.  Sequences within this range are printed to
        rixyin, sequ and riinst depending also on the fifth parameter.

      * lowerValue,upperValue (two reals): the lowest and highest Value
        evaluation to report to rixyin, sequ and riinst.  If the first
        character of the line is 'a' then all evaluations are reported.
        Otherwise two real numbers are expected.  Sequences within this range
        are printed to rixyin, sequ and riinst depending also on the fifth
        parameter.

      * printsequ (character):  determines whether or not to produce any raw
        sequences in the sequ file.  If the first character of the line is
        'p', sequences selected according to the third and fouth parameters
        are printed to sequ file.  (This is a complete on-off switch for the
        sequ file.)

      * printrixyin (character):  determines whether or not to print the
        sequence of the site being analyzed.  If the first character is 'p'
        then the sequence is printed to the rixyin file.

     * partials (character): determines whether or not to print sequences
        which have a partial site.  The problem is that if there is part of a
        site, then the Ri value is questionable, depending on where the
        deletion was.  The best analysis would not use a partial site, as it
        messes up the statistics.  If the first character is:

         n  Don't print the line at all.
         i  Keep the line, but force the Ri value to be -infinity.
            This allows the lines of rixyin to be correlated to the values
            still.
         -  (any other character): print as it is.

      * niot (character (one of 'slnb') and/or real): negative infinity or
         t:  determines what to do when f(b,l) = 0.  Positions for which
         f(b,l) = 0 will have negative infinity in the Ri(b,l) table.  The
         letter 's' means to use an "extended" Rodger Staden's method of
         giving f(b,l) = 1/(n+t), where t is a non-negative integer following
         the 's'.  When t = 0, this gives Staden's original method.  Using
         t = 1 would often give frequencies that are too low.  The value of
         t=2 corresponds to the Laplace Law of Succession.

         The ``law of succession of Laplace''
         \cite{Feller1968.Laplace,Papoulis1990} states that given $n$ trials
         in which there were $k$ results of one kind, the best estimate for
         the probability in another trial is $(k+1)/(n+2)$.  In the present
         case, we need the probability of the absence of a particular base
         when searching for {\em another\/} binding site, so $k = 0$ and the
         best estimate is $1/(n+2)$.  For this reason we set $t=2$ for most
         purposes.

         If instead of 's' for Staden's extended method, 'l' is used, the
         program will use the full Laplace Law of sucession

             f(b,l) = (k+1)/(n+2) = (n(b,l)+1)/(n(l)+2)

         as the estimate for the probability for k items out of n total.
         This OVERESTIMATES the information content and so is NOT to be used
         in general.  (This can be easily demonstrated by looking at the
         effect on the average of the distribution.)

         If the character is 'b' then Staden's method is used as above but
         Ehnb is not added.  This is ONLY to be used to simulate the bug
         corrected on 2001 May 10!  (See Technical Notes below.)

         If there is no 's', 'l' or 'b', (or when the line begins with 'n')
         then the program expects a number which the value for negative
         infinity.  It should be a value sufficiently below zero so that
         sites that are being excluded from the definition according to
         f(b,l) are separated from the true sites.  -1000 is a useful value,
         as it will always displace sites with exceptions far away from
         zero.

      * alignmenttype (character): defines how to align the pieces.  See the
        alist program for the detailed logic.  There are three choices, as in
        alist:

         'f' (for 'first') then the sequences are always aligned by their
         first base.

         'i' then the sequences are aligned by the delila instructions.  If
         the inst file is empty, alignment is forced to the 'b' mode.

         'b' (for 'internal') then the alignment is on the internal zero of
         the book's sequence.  This option is to be used when "default
         coordinate zero" is used in the Delila instructions.

       * Ribound (real): the Ri boundary for this definition, bits.
            The lower bound on Ri to find in the book.
            Use 0 to represent the Second Law of Thermodynamic bound.
            Use -500 or lower to locate all sites. 

       * Zbound (real): the Z boundary for this definition.
            The lower bound on Z (standard deviation) to find in the
            book.
            Use 100 to locate all sites.

       * Pbound (real): the probability boundary for this definition.
            The upper probability P to find in the book.
            Use 1.00 to locate all sites.

       Ribound, Zbound and Pbound are used in conjunction, so 0, 100,
       1.00 respectively would locate all sites greater than zero
       bits, with no other constraint.  Most of the time we adjust
       Ribound and do not play with the others.

   wave: Define a cosine wave.  See makelogo for the definition of this
         file.  These data are simply copied to the end of the ribl file.
         This allows the lister program to create a wave under the walkers If
         you use the same wave definition for makelogo, the same wave in the
         logo will be on the walker.

   rixyin: input to the xyplo program.  The file contains these columns of data:
         1 piece number
         2 piece name
         3 sequence of region analyzed 
         4 length of region analyzed on this piece
         5 aligning coordinate on the piece
         6 Rindividual for the piece
         7 value from the values file (or 0 if values is empty)
         8 standard deviation of Rindividual for that sequence.

zzzqqq describe Ri SD computation here.  This computation is EXPERIMENTAL.
The statistics is NOT PROVEN and the program is not even guaranteed
to compute this unproven value correctly!

2002 Jan 24

risd = Ri standard deviation

the test directory contains a functioning routine
that works - in pascal.  It needs to be boiled down more.

2002 Jan 29

Here is the comptuation, at a position l with n(l) sequences
and f(b,l) = n(b,l)/n(l).
If the frequency is zero, then use

f := 1/(2+n(l))
otherwise use
f := f(b,l)

The (corrected to account for n(l) variation) formula given in the perl
program is

variance = ((1-f)/f)/n(l)

or

variance = ((1/f-1)/n(l)

for most cases where n(b,l) > 0

For simplicity let
b = n(b,l)
n = n(l)

variance = ((1/f(b,l)-1)/n(l)
         = ((1/(n(b,l)/n(l))-1)/n
         = ((1/(b/n))-1)/n
         = (1/b)- (1/n)

which is amusingly simple.
********************************************************************************
   sequ: the raw sequences reported to rixyin if any selection is made
      (fourth line of rip file).  These end in periods, so they can be
      given to makebk to create a book.

   ribl: weight matrix Ri(b,l).  The file begins with the name of the weight
      matrix.  It contains the information content for each base b at
      each position l, in bits.  Lines that start with * are notes.  The next
      line contains the matrix FROM and TO coordinates (thefrom and theto).

      This is followed by the matrix in the order A, C, G, T from FROM to TO.

      At the end of each line of the matrix is the position (integer)
      followed by the numbers of bases (A, C, G, T) at that position.

      After the matrix, real numbers on individual lines report:
         Ri mean (Rsequence of selected region)
         Ri standard deviation
         Ri of consensus sequence
         Ri of anticonsensus sequence
         Ri average for random (equiprobable) sequence
         the value of negative infinity
      These are all for the given range.
      (Note: Although the mean Ri for the sites is Rsequence, to get a good
      estimate of this, it is better to use the value calculated by the rseq
      program because that is less sensitive to missing sequence data.)

      Then one integer is given; n the number of sequences.

      Then, the symmetry of the matrix is defined by the first character
      on the final line:
          a: asymmetric
          o: odd symmetry (the zero base is in the center)
          e: even symmetry (the zero base is left of the center)

      The file contains any number of wave definitions, copied
      from the wave file.

      The file ends with a period, ".".

   riinst: Delila instructions for the selected subset of sites according to
      the parameters lowerRi, upperRi, lowerValue, upperValue.  The gets are
      given in this form:



piece K01789; get from 283 -FROM to same +TO direction +; (@ 4.555974 bits @)

      This allows the user to substitute a range for the FROM and TO tags.
      For example, using the unix sed:

         cat riinst | sed -e "s/FROM/50/" | sed -e "s/TO/50/" > newinst

      gives results like this:

piece K01789; get from 283 -50 to same +50 direction +; (@ 4.555974 bits @)

      See bugs.
      (In the actual instructions the '@' is replaced with *; it
      can't be in these examples because they are comments in
      the source code.)

   output: messages to the user

description
   The program determines the individual informations of the sites in the book
   as aligned by the instructions, according to the frequency table given in
   the rsdata file.  The program calculates the Ri(b,l) table:

       Ri(b,l) := 2 - (- log2( f(b,l)))

   and sums this up for each sequence.  Ri is defined so that the average of
   the Ri's for a set of sequences is Rsequence.  However, if the sequences are
   incomplete, the average will probably be less than Rsequence.  The rixyin
   output is ready to read into the xyplo program for plotting and linear
   regression.  The ribl matrix is ready to be used to scan sequences with the
   scan program.

   The program can be used in subtle ways.  For example, one can analyze the
   individual information of the left half of a binding site.  This result can
   then be used in the values file to compare against the analysis of the right
   side of a binding site.

examples

rip:

2.54          version of ri that this parameter file is designed for.
"Fis"         name of the ribl matrix
-10 +10       From-to range to do the evaluation
1             column of the values file to copy to xyin
a 0 1000      lowest to highest Ri to put in xyin and sequ (a = any)
a -1000 +1000 lowest to highest Value to put in xyin and sequ (a = any)
n             p means print sequence to the sequ file
p             p means print sequence to the xyin file
-             -: accept all sites; n: no partials; i: partials -> -infinity
s 2           s: use Staden's Method, f(b,l)=1/(n+t); else negative infinity
i             alignmenttype first, book, instructions
-5000         Ribound: real; the Ri boundary for this definition
100           Zbound:  real; the Z boundary for this definition
1.00          Pbound:  real; the probability boundary for this definition

documentation

@article{Schneider.Ri,
author = "T. D. Schneider",
title = "Information Content of Individual Genetic Sequences",
journal = "J. Theor. Biol.",
volume = "189",
number = "4",
pages = "427-441",
note = "\htmladdnormallink
{https://alum.mit.edu/www/toms/paper/ri/}
{https://alum.mit.edu/www/toms/paper/ri/}",
comment = "indiv.tex",
comment = "Submitted, April 1997",
year = "1997"}

@article{Schneider.walker,
author = "T. D. Schneider",
title = "Sequence Walkers:
a graphical method to display how binding proteins
interact with {DNA} or {RNA} sequences",
journal = "Nucl. Acids Res.",
volume = "25",
comment = "walker.tex, November 1, issue 21",
note = "\htmladdnormallink
{https://alum.mit.edu/www/toms/paper/walker/}
{https://alum.mit.edu/www/toms/paper/walker/},
erratum: NAR 26(4): 1135, 1998",
pages = "4408-4415",
year = "1997"}

@article{Staden1984,
author = "R. Staden",
title = "Computer methods to locate signals in nucleic acid sequences",
journal = "Nucl. Acids Res.",
volume = "12",
pages = "505-519",
year = "1984"}

@inproceedings{Feller1968.Laplace,
author = "William Feller",
booktitle = "An Introduction to Probability Theory and Its Applications",
volume = "I",
edition = "3rd",
publisher = "John Wiley \& Sons, Inc.",
address = "New York",
isbn = "0-471-25708-7",
pages = "123-124",
year = "1968"}

@book{Papoulis1990,
author = "Athanasios Papoulis",
title = "Probability \& Statistics",
publisher = "Prentice Hall",
address = "Englewood Cliffs, NJ",
comment = "Englewood Cliffs NJ 07632
QA273.P197 1990 / ISBN 0-13-711698-5.
The Laplace law of succession is on page 173",
year = "1990"}

see also
   {program that generates the rsdata file: } rseq.p

   {program to plot the rixyin data file:   } xyplo.p

   {program that uses the ribl file for searches: } scan.p

   {program that uses the ribl to create an interactive
    display of sequence walkers: } makewalker.p

   {program that uses the output of the scan program
    to display multiple sequence walkers and other features
    and marks along a sequence: } lister.p

   {program that should be run to get a sequence logo
    before attempting to use this program to make walkers: } makelogo.p

   {modules used internally to this program are in: } prgmod.p

   {For people who have the ri program installed, example files are in your
   ii/delila directory under under files beginning with 'fis'.}

author

   Thomas D. Schneider

bugs

   In riinst the organism and chromosome names are not written because they
   are not available by the alignment method of reading.  For now the
   instructions are given as:
       organism ORG; chromosome CHR;
   Of course this only will work for a single organism, but that is useful!


   2001 May 10:  Weight Matrix Bug corrected

The weight function is Ri = Enbh+log2(f) where f is the frequency of a
base in an aligned position, Enbh ~ 2 (2 with small sample
correction).  If f is zero the function goes to negative infinity. 
Since that is too extreme - another sequence might contain the base -
in the Staden-like method we use an estimate for f in that case,
1/(n+2) which is the best estimate of the frequency given the small
sample size.

Example of the bug.  With n = 18, (and putting Enhb=2 for simplicity)
we have Ri = 2 + log2(1/20) = -2.32.  Oh no!  The weights are -4.32! 
I looked into the code (the routine is Ricalc) and found that there is
a bug!  I forgot to add the 'Enbh' part.

Versions of Ri up to 2.64 incorrectly used Ri = log2(1/(n+2)) instead
of the correct function when the number of bases is zero.  This means
that the scan program has been missing some sites because they were
weighted too low.  To allow for comparison to previous versions of the
code, the niot parameter can be set to 'b'.  This should not be used
normally.

*/
#include <getopt.h>  /* getopt API */ 
#include <stdio.h>   /* printf */
#include <stdlib.h> 
#include </home/mplace/bin/p2c/src/p2c.h>
#define version         2.82
#define updateversion   2.53
#define infofield       10
#define infodecim       6
#define nfield          8
#define minribl         (-10001)
#define maxribl         10001
#define defnegativeinfinity  (-1000)
#define maxstring       2000
#define fillermax       21
#define dnamax          3000
#define namelength      12
#define linelength      80
#define datetimearraylength  19

typedef struct stringDelila {
  Char letters[maxstring];
  long length;
  long current;
  struct stringDelila *previous, *next;
} stringDelila;

typedef Char filler[fillermax];

typedef struct trigger {
  stringDelila seek;
  long state;
  boolean skip;
  boolean found;
} trigger;

typedef struct rstype {
  long rstart, rstop, l, nal, ncl, ngl, ntl;
  double rsl, rs, varhnb, sumvar;
  long nl;
  double ehnb;
  Char flag;
} rstype;

typedef long chset[5];
typedef Char alpha[namelength];

typedef struct name {
  alpha letters;
  char length;
} name;

typedef struct line {
  Char letters[linelength];
  char length;
  struct line *next;
} line;

typedef enum {
  plus, minus, dircomplement, dirhomologous
} direction;
typedef enum {
  linear, circular
} configuration;
typedef enum {
  on, off
} state;

typedef struct header {
  name keynam;
  line *fulnam, *note;
} header;

typedef enum {
  a, c, g, t
} base;

typedef short dnarange;

/* p2c: ri.p, line 620:
 * Note: Field width for seq assumes enum base has 4 elements [105] */
typedef uchar seq[(dnamax + 3) / 4];

typedef struct dnastring {
  seq part;
  dnarange length;
  struct dnastring *next;
} dnastring;

typedef struct orgkey {
  header hea;
  line *mapunit;
} orgkey;

typedef struct chrkey {
  header hea;
  double mapbeg, mapend;
} chrkey;

typedef struct piekey {
  header hea;
  double mapbeg;
  configuration coocon;
  direction coodir;
  long coobeg, cooend;
  configuration piecon;
  direction piedir;
  long piebeg, pieend;
} piekey;

typedef struct piece {
  piekey key;
  dnastring *dna;
} piece;

typedef struct reference {
  name pienam;
  double mapbeg;
  direction refdir;
  long refbeg, refend;
} reference;

typedef struct genkey {
  header hea;
  reference ref;
} genkey;

typedef struct trakey {
  header hea;
  reference ref;
} trakey;

typedef struct markey {
  header hea;
  reference ref;
  state sta;
  line *phenotype;
  struct marker *next;
} markey;

typedef struct marker {
  markey key;
  dnastring *dna;
} marker;

typedef struct waveparam {

  Char extreme;
  double wavelocation, wavebit, waveamplitude, wavelength;
  double dashon;
  double dashoff, dashoffset, thickness;
  struct waveparam *next;
} waveparam;

typedef double rblarray[(long)t - (long)a + 1][maxribl - minribl + 1];

typedef struct ribltype {
  stringDelila riblname, *riblheader;
  rblarray data;
  long numbers[(long)t - (long)a + 1][maxribl - minribl + 1];
  long frombase, tobase;
  double mean, stdev, consensus, anticonsensus, averageRi;
  long n;
  Char symmetry;
  waveparam *waves;
  double cmperbase, cmperbit, Ribound, Zbound, Pbound;
} ribltype;

typedef Char datetimearray[datetimearraylength];

Static _TEXT inst, book, rsdata, values, rip, wave, rixyin, sequ, ribl,
	     riinst;

Static line *freeline;
Static dnastring *freedna;
Static boolean readnumber;
Static long number;
Static boolean numbered, skipunnum;
Static jmp_buf _JL1;

Static Void halt()
{
  printf(" program halt.\n");
  longjmp(_JL1, 1);
}

/* Local variables for pluckdigit: */
struct LOC_pluckdigit {
  long place, myabsolute;
  Char acharacter;
} ;

Local Void digit(LINK)
struct LOC_pluckdigit *LINK;
{
  long tenplace, z, d;

  tenplace = LINK->place * 10;
  z = LINK->myabsolute - LINK->myabsolute / tenplace * tenplace;
  if (LINK->place == 1)
    d = z;
  else
    d = z / LINK->place;
  switch (d) {
  case 0:
    LINK->acharacter = '0';
    break;
  case 1:
    LINK->acharacter = '1';
    break;
  case 2:
    LINK->acharacter = '2';
    break;
  case 3:
    LINK->acharacter = '3';
    break;
  case 4:
    LINK->acharacter = '4';
    break;
  case 5:
    LINK->acharacter = '5';
    break;
  case 6:
    LINK->acharacter = '6';
    break;
  case 7:
    LINK->acharacter = '7';
    break;
  case 8:
    LINK->acharacter = '8';
    break;
  case 9:
    LINK->acharacter = '9';
    break;
  }
}

Local Char pluckdigit(number, logplace)
long number, logplace;
{
  struct LOC_pluckdigit V;
  long count;

  V.place = 1;
  for (count = 1; count <= logplace; count++)
    V.place *= 10;
  if (number == 0) {
    V.acharacter = '0';
    return V.acharacter;
  }
  V.myabsolute = number;
  if (V.myabsolute >= V.place)
    digit(&V);
  else
    V.acharacter = '0';
  return V.acharacter;
}


/* get the date and time into a single array from the system clock.
   adatetime contains the date:
       1980/06/09 18:49:11
         ye mo da ho mi se
(year, month, day, hour, minute, second).
As of 2000 February 18, the Sun Pascal compiler requires a formatting
statement.  This statement allows the date to be generated in this
standard Delila format in a single call.  Information about the
formatting statement is available on the manual page for date in Unix.
If a computer does not have this method, see the 'oldgetdatetime' routine
in delmod.p (https://alum.mit.edu/www/toms/delila/delmod.html)
for some conversion code.

GPC Functions:
function  GetUnixTime (var MicroSecond : Integer) : UnixTimeType;

http://agnes.dida.physik.uni-essen.de/~gnu-pascal/gpc_109.html#SEC109

7.10.8 Date And Time Routines 

procedure GetTimeStamp (var t : TimeStamp); 
function Date (t : TimeStamp) : packed array [1 .. DateLength] of Char; 
function Time (t : TimeStamp) : packed array [1 .. TimeLength] of Char; 

DateLength and TimeLength are implementation dependent constants. 

GetTimeStamp (t) fills the record `t' with values. If they are valid, the Boolean
flags are set to True. 

TimeStamp is a predefined type in the Extended Pascal standard. It may be
extended in an implementation, and is indeed extended in GPC. For the full
definition of `TimeStamp', see section 8.255 TimeStamp. */
Static Void getdatetime(adatetime)
Char *adatetime;
{
  
  Char adate[datetimearraylength], atime[datetimearraylength];
  Char month[3];
  long index;

  VAXdate(adate);
  VAXtime(atime);

  for (index = 1; index <= 4; index++)
    adatetime[index-1] = adate[index+6];
  adatetime[4] = '/';
  for (index = 4; index <= 6; index++)
    month[index-4] = adate[index-1];
  if (!strncmp(month, "JAN", 3)) {
    adatetime[5] = '0';
    adatetime[6] = '1';
  } else if (!strncmp(month, "FEB", 3)) {
    adatetime[5] = '0';
    adatetime[6] = '2';
  } else if (!strncmp(month, "MAR", 3)) {
    adatetime[5] = '0';
    adatetime[6] = '3';
  } else if (!strncmp(month, "APR", 3)) {
    adatetime[5] = '0';
    adatetime[6] = '4';
  } else if (!strncmp(month, "MAY", 3)) {
    adatetime[5] = '0';
    adatetime[6] = '5';
  } else if (!strncmp(month, "JUN", 3)) {
    adatetime[5] = '0';
    adatetime[6] = '6';
  } else if (!strncmp(month, "JUL", 3)) {
    adatetime[5] = '0';
    adatetime[6] = '7';
  } else if (!strncmp(month, "AUG", 3)) {
    adatetime[5] = '0';
    adatetime[6] = '8';
  } else if (!strncmp(month, "SEP", 3)) {
    adatetime[5] = '0';
    adatetime[6] = '9';
  } else if (!strncmp(month, "OCT", 3)) {
    adatetime[5] = '1';
    adatetime[6] = '0';
  } else if (!strncmp(month, "NOV", 3)) {
    adatetime[5] = '1';
    adatetime[6] = '1';
  } else if (!strncmp(month, "DEC", 3)) {
    adatetime[5] = '1';
    adatetime[6] = '2';
  }
  adatetime[7] = '/';
  for (index = 7; index <= 8; index++)
    adatetime[index+1] = adate[index-7];


  if (adatetime[5] == ' ')
    adatetime[5] = '0';
  if (adatetime[8] == ' ')
    adatetime[8] = '0';

  adatetime[10] = ' ';
  for (index = 10; index <= 17; index++)
    adatetime[index+1] = atime[index-10];
}

Static Void readdatetime(thefile, adatetime)
_TEXT *thefile;
Char *adatetime;
{
 long index;
  Char udatetime[datetimearraylength];

  for (index = 0; index < datetimearraylength; index++) {
    udatetime[index] = getc(thefile->f);
    if (udatetime[index] == '\n')
      udatetime[index] = ' ';
  }
  memcpy(adatetime, udatetime, sizeof(datetimearray));
  if (adatetime[2] == '/' && adatetime[11] == ':') {
    printf("You have an old datetime (only 2 year digits): \n");
    for (index = 0; index < datetimearraylength; index++)
      putchar(adatetime[index]);
    printf("\nConvert your database to 4 digit years.\n");
    halt();
  }
  /*

*/
  if (adatetime[4] == '/' && adatetime[7] == '/' && adatetime[13] == ':' &&
      adatetime[16] == ':')
    return;
  printf("readdatetime: bad date time read:\n");
  for (index = 0; index < datetimearraylength; index++)
    putchar(adatetime[index]);
  putchar('\n');
  halt();
}


/* Read the computer date and time.  Reverse the order of the digits and put
a decimal point in front.  This gives a fraction between zero and one that
varies quite quickly, and is always unique (if the computer has sufficient
accuracy).  It is to be used as a seed to a random number generator.  This
has the nice property that the seed changes every second and does not repeat
for thousands of years!  */
Static Void writedatetime(thefile, adatetime)
_TEXT *thefile;
Char *adatetime;
{
  long index;

  for (index = 0; index < datetimearraylength; index++)
    putc(adatetime[index], thefile->f);
}

/* add the digit represented by c to the seed at the power position */
Static Void addtoseed(seed, power, c)
double *seed, *power;
Char c;
{
  long n;
  *power /= 10;
  
  n = c - '0';
  if ((unsigned long)n > 9) {
    printf("timeseed: error in datetime\n");
    printf("it contains \"%c\" which is not a number.\n", c);
    printf("The getdatetime routine must be fixed.\n");
    halt();
  }
  *seed += *power * n;
}

Static Void makeseed(adatetime, seed)
Char *adatetime;
double *seed;
{
  double power = 1.0;
  *seed = 0.0;
  addtoseed(seed, &power, adatetime[18]);
  addtoseed(seed, &power, adatetime[17]);
  addtoseed(seed, &power, adatetime[15]);
  addtoseed(seed, &power, adatetime[14]);
  addtoseed(seed, &power, adatetime[12]);
  addtoseed(seed, &power, adatetime[11]);
  addtoseed(seed, &power, adatetime[9]);
  addtoseed(seed, &power, adatetime[8]);
  addtoseed(seed, &power, adatetime[6]);
  addtoseed(seed, &power, adatetime[5]);
  addtoseed(seed, &power, adatetime[3]);
  addtoseed(seed, &power, adatetime[2]);
  addtoseed(seed, &power, adatetime[1]);
  addtoseed(seed, &power, adatetime[0]);
}

Static Void orderseedDelila(adatetime, seed)
Char *adatetime;
double *seed;
{
  double power = 1.0;
  *seed = 0.0;
  addtoseed(seed, &power, adatetime[2]);
  addtoseed(seed, &power, adatetime[3]);
  addtoseed(seed, &power, adatetime[5]);
  addtoseed(seed, &power, adatetime[6]);
  addtoseed(seed, &power, adatetime[8]);
  addtoseed(seed, &power, adatetime[9]);
  addtoseed(seed, &power, adatetime[11]);
  addtoseed(seed, &power, adatetime[12]);
  addtoseed(seed, &power, adatetime[14]);
  addtoseed(seed, &power, adatetime[15]);
  addtoseed(seed, &power, adatetime[17]);
  addtoseed(seed, &power, adatetime[18]);
}

Static Void timeseed(seed)
double *seed;
{
  datetimearray adatetime;
  getdatetime(adatetime);
  makeseed(adatetime, seed);
}

Static Void limitdate(a_, b, c_, d, limitdatetime_)
Char a_, b, c_, d;
Char *limitdatetime_;
{
  datetimearray limitdatetime, adatetime;
  double Dday, now;
  memcpy(limitdatetime, limitdatetime_, sizeof(datetimearray));
  getdatetime(adatetime);
  orderseedDelila(adatetime, &now);

  if (limitdatetime[0] != ' ' || limitdatetime[1] != ' ' ||
      limitdatetime[2] != ' ' || limitdatetime[3] != ' ')
    halt();

  limitdatetime[0] = a_;
  limitdatetime[1] = b;
  limitdatetime[2] = c_;
  limitdatetime[3] = d;
  orderseedDelila(limitdatetime, &Dday);

  if (now <= Dday)
    return;
  printf("This program expired on %.*s\n", datetimearraylength, limitdatetime);
  printf("See: https://alum.mit.edu/www/toms/walker/contacts.html\n");
  halt();
}

Static Void emptystring(ribbon)
stringDelila *ribbon;
{
  long index;
  for (index = 0; index < maxstring; index++)
    ribbon->letters[index] = ' ';
  ribbon->length = 0;
  ribbon->current = 0;
}

Static Void clearstring(ribbon)
stringDelila *ribbon;
{
  emptystring(ribbon);
  ribbon->previous = NULL;
  ribbon->next = NULL;
}

Static Void disposestring(ribbon)
stringDelila **ribbon;
{
  stringDelila *t_;
  t_ = *ribbon;

  while (t_->next != NULL)
    t_ = t_->next;

  while (t_->previous != NULL) {
    t_ = t_->previous;
    Free(t_->next);
  }
  Free(t_);
}

Static Void initializestring(ribbon)
stringDelila *ribbon;
{
  printf("remove initializestring routine!\n");
  printf("replace it with clearstring routine!\n");
  halt();
  clearstring(ribbon);
  ribbon->next = NULL;
}

Static Void writestring(tofile, s)
_TEXT *tofile;
stringDelila *s;
{
  long i, FORLIM;
  FORLIM = s->length;
  for (i = 0; i < FORLIM; i++)
    putc(s->letters[i], tofile->f);
}

Static Void fillstring(s, a_)
stringDelila *s;
Char *a_;
{
  long length = fillermax;
  long index;

  clearstring(s);
  while (length > 1 && a_[length-1] == ' ')
    length--;
  if (length == 1 && a_[length-1] == ' ') {
    printf("fillstring: the string is empty\n");
    halt();
  }

  for (index = 0; index < length; index++)
    s->letters[index] = a_[index];
  s->length = length;
  s->current = 1;
}

Static Void filltrigger(t_, a_)
trigger *t_;
Char *a_;
{
  fillstring(&t_->seek, a_);
}

Static Void resettrigger(t_)
trigger *t_;
{
  t_->state = 0;
  t_->skip = false;
  t_->found = false;
}

Static Void testfortrigger(ch, t_)
Char ch;
trigger *t_;
{
  t_->state++;

  if (t_->seek.letters[t_->state - 1] == ch) {
    t_->skip = false;
    if (t_->state == t_->seek.length)
      t_->found = true;
    else
      t_->found = false;
    return;
  }

  if (t_->seek.letters[0] == ch) {
    t_->state = 1;
    t_->skip = false;
    t_->found = false;
    return;
  }
  t_->state = 0;
  t_->skip = true;
  t_->found = false;
}

#define tab             9

Static boolean isblankDelila(c_)
Char c_;
{
  return (c_ == ' ' || c_ == tab);
}
#undef tab

Static Void skipblanks(thefile)
_TEXT *thefile;
{
  while (isblankDelila(P_peek(thefile->f)) & (!P_eoln(thefile->f)))
    getc(thefile->f);
}

Static Void skipnonblanks(thefile)
_TEXT *thefile;
{
  while ((!isblankDelila(P_peek(thefile->f))) & (!P_eoln(thefile->f)))
    getc(thefile->f);
}

Static Void skipcolumn(thefile)
_TEXT *thefile;
{
  skipblanks(thefile);
  skipnonblanks(thefile);
}

Static Void copyaline(fin, fout)
_TEXT *fin, *fout;
{
  while (!P_eoln(fin->f)) {
    putc(P_peek(fin->f), fout->f);
    getc(fin->f);
  }
  fscanf(fin->f, "%*[^\n]");
  getc(fin->f);
  putc('\n', fout->f);
}

#define tabcharacter    9

Static Void readquotestring(afile, s)
_TEXT *afile;
stringDelila *s;
{
  Char c_;
  long i, FORLIM;

  emptystring(s);
  skipblanks(afile);
  c_ = getc(afile->f);
  if (c_ == '\n')
    c_ = ' ';
  if (c_ != '"') {
    printf("quote string expected but \" missing\n");
    printf("character found instead:\"%c\"\n", c_);
    halt();
  }
  if (P_eoln(afile->f)) {
    printf("missing end of quote string \" string\n");
    halt();
  }
  do {
    c_ = getc(afile->f);
    if (c_ == '\n')
      c_ = ' ';
    if (c_ != '"') {
      s->length++;
      s->letters[s->length - 1] = c_;
    }
  } while (!(((c_ == '"') | P_eoln(afile->f)) || s->length == maxstring));
  if (s->length == maxstring) {
    printf("A quote string exceeded %ld characters.\n", (long)maxstring);
    printf("Use a shorter string or increase constant maxstring.\n");
    halt();
  }
  if (c_ != '"') {
    printf("The second \" mark of a string is missing.\n");
    halt();
  }

  FORLIM = s->length;
  for (i = 0; i < FORLIM; i++) {
    if (s->letters[i] == ' ')
      s->letters[i] = (Char)tabcharacter;
  }
}
#undef tabcharacter

Static Void grabtoken(thefile, thestring)
_TEXT *thefile;
stringDelila *thestring;
{
  Char c_;
  boolean done = false;

  skipblanks(thefile);
  thestring->length = 0;
  while (!done) {
    if (P_eoln(thefile->f)) {
      done = true;
      break;
    }
    c_ = getc(thefile->f);
    if (c_ == '\n')
      c_ = ' ';
    if (c_ == ' ')
      done = true;
    else {
      thestring->length++;
      thestring->letters[thestring->length - 1] = c_;
    }
  }
}
#define tabcharacter    9

Static Void detabstring(s)
stringDelila *s;
{
  Char c_;
  long i, FORLIM;

  FORLIM = s->length;
  for (i = 0; i < FORLIM; i++) {
    c_ = s->letters[i];

    if (c_ == tabcharacter)
      c_ = ' ';
    s->letters[i] = c_;
  }
}
#undef tabcharacter

Static Void writequotestring(afile, s)
_TEXT *afile;
stringDelila s;
{
  detabstring(&s);
  putc('"', afile->f);
  writestring(afile, &s);
  putc('"', afile->f);
}

Static Void readstringline(afile, buffer)
_TEXT *afile;
stringDelila *buffer;
{
  long index = 0;

  clearstring(buffer);
  while (!P_eoln(afile->f) && index < maxstring) {
    index++;
    buffer->letters[index-1] = getc(afile->f);
    if (buffer->letters[index-1] == '\n')
      buffer->letters[index-1] = ' ';
  }
  if (!P_eoln(afile->f)) {
    printf("readstringline: a line exceeds maximum string size (%ld)\n",
	   (long)maxstring);
    halt();
  }
  buffer->length = index;
  buffer->current = 1;
  fscanf(afile->f, "%*[^\n]");
  getc(afile->f);
}

Static Void writestringlines(afile, l)
_TEXT *afile;
stringDelila *l;
{
  stringDelila *h;

  if (l == NULL)
    return;
  h = l;
  while (h != NULL) {
    writestring(afile, h);
    putc('\n', afile->f);
    h = h->next;
  }
}

Static Void readheader(afile, ch, theheader)
_TEXT *afile;
Char ch;
stringDelila **theheader;
{
  stringDelila *h;

  if (BUFEOF(afile->f)) {
    clearstring(*theheader);
    return;
  }
  if (P_peek(afile->f) != ch) {
    *theheader = NULL;
    return;
  }
  *theheader = (stringDelila *)Malloc(sizeof(stringDelila));
  h = *theheader;
  while (P_peek(afile->f) == '*') {
    readstringline(afile, h);
    if (!BUFEOF(afile->f)) {
      if (P_peek(afile->f) == '*') {
	h->next = (stringDelila *)Malloc(sizeof(stringDelila));
	h = h->next;
      } else
	h->next = NULL;
    }
  }
}

Static Void getlineDelila(l)
line **l;
{
  if (freeline != NULL) {
    *l = freeline;
    freeline = freeline->next;
  } else
    *l = (line *)Malloc(sizeof(line));
  (*l)->length = 0;
  (*l)->next = NULL;
}

Static Void getdna(l)
dnastring **l;
{
  if (freedna != NULL) {
    *l = freedna;
    freedna = freedna->next;
  } else
    *l = (dnastring *)Malloc(sizeof(dnastring));
  (*l)->length = 0;
  (*l)->next = NULL;
}

Static Void clearline(l)
line **l;
{
  line *lptr;

  if (*l == NULL)
    return;
  lptr = *l;
  *l = (*l)->next;
  lptr->next = freeline;
  freeline = lptr;
}

Static Void writeline(afile, l, carriagereturn)
_TEXT *afile;
line *l;
boolean carriagereturn;
{
  long index, FORLIM;

  FORLIM = l->length;
  for (index = 0; index < FORLIM; index++)
    putc(l->letters[index], afile->f);
  if (carriagereturn)
    putc('\n', afile->f);
}

Static Void showfreedna()
{
  long counter = 0;
  dnastring *l;

  l = freedna;
  while (l != NULL) {
    counter++;
    printf("%ld", counter);
    printf(", length = %d\n", l->length);
    l = l->next;
  }
}

Static Void cleardna(l)
dnastring **l;
{
  dnastring *lptr;

  if (*l == NULL)
    return;
  lptr = *l;
  *l = (*l)->next;
  lptr->next = freedna;
  freedna = lptr;
}

Static Void clearheader(h)
header *h;
{
  clearline(&h->fulnam);
  while (h->note != NULL)
    clearline(&h->note);
}

Static Void clearpiece(p)
piece **p;
{
  while ((*p)->dna != NULL)
    cleardna(&(*p)->dna);
  clearheader(&(*p)->key.hea);
}

Static base chartobase(ch)
Char ch;
{
  base Result;

  switch (ch) {
  case 'a':
    Result = a;
    break;
  case 'c':
    Result = c;
    break;
  case 'g':
    Result = g;
    break;
  case 't':
    Result = t;
    break;
  }
  return Result;
}

Static Char basetochar(ba)
base ba;
{
  Char Result;

  switch (ba) {
  case a:
    Result = 'a';
    break;
  case c:
    Result = 'c';
    break;
  case g:
    Result = 'g';
    break;
  case t:
    Result = 't';
    break;
  }
  return Result;
}


Static base complement(ba)
base ba;
{
  base Result;
  switch (ba) {
  case a:
    Result = t;
    break;
  case c:
    Result = g;
    break;
  case g:
    Result = c;
    break;
  case t:
    Result = a;
    break;
  }
  return Result;
}

Static Char chomplement(b)
Char b;
{
  return (basetochar(complement(chartobase(b))));
}

Static long pietoint(p, pie)
long p;
piece *pie;
{
  long i;
  piekey *WITH;

  WITH = &pie->key;
  switch (WITH->piedir) {

  case dirhomologous:
  case plus:
    if (p >= WITH->piebeg)
      i = p - WITH->piebeg + 1;
    else
      i = p - WITH->coobeg + WITH->cooend - WITH->piebeg + 2;
    break;

  case dircomplement:
  case minus:
    if (p <= WITH->piebeg)
      i = WITH->piebeg - p + 1;
    else
      i = WITH->cooend - p + WITH->piebeg - WITH->coobeg + 2;
    break;
  }
  return i;
}


Static long inttopie(i, pie)
long i;
piece *pie;
{

  long p;
  piekey *WITH;

  WITH = &pie->key;
  switch (WITH->piedir) {

  case dirhomologous:
  case plus:
    p = WITH->piebeg + i - 1;
    if (p > WITH->cooend) {
      if (WITH->coocon == circular)
	p += WITH->coobeg - WITH->cooend - 1;
    }
    break;

  case dircomplement:
  case minus:
    p = WITH->piebeg - i + 1;
    if (p < WITH->coobeg) {
      if (WITH->coocon == circular)
	p += WITH->cooend - WITH->coobeg + 1;
    }
    break;
  }
  return p;
}


Static long piecelength(pie)
piece *pie;
{
  return (pietoint(pie->key.pieend, pie));
}

Static Char getto(thefile, theline, ch)
_TEXT *thefile;
long *theline;
long *ch;
{
  Char achar = ' ';
  boolean done = false;

  while (!done) {
    if (BUFEOF(thefile->f)) {
      done = true;
      break;
    }
    achar = P_peek(thefile->f);
    if (P_inset(achar, ch)) {
      done = true;
      break;
    }
    fscanf(thefile->f, "%*[^\n]");
    getc(thefile->f);
    (*theline)++;
  }
  if (P_inset(achar, ch))
    return achar;
  else {
    return ' ';
  }
}



Static Void skipstar(thefile)
_TEXT *thefile;
{
  if (BUFEOF(thefile->f)) {
    printf(" procedure skipstar: end of book found\n");
    halt();
    return;
  }
  if (P_peek(thefile->f) != '*') {
    printf(" procedure skipstar: bad book\n");
    printf(" \"*\" expected as first character on the line, but \"%c\" was found\n",
	   P_peek(thefile->f));
    halt();
  }
  getc(thefile->f);
  if (P_peek(thefile->f) != ' ') {
    printf(" procedure skipstar: bad book\n");
    printf(" \"* \" expected on a line but \"*%c\" was found\n",
	   P_peek(thefile->f));
    halt();
  }
  getc(thefile->f);
}

Static Void brreanum(thefile, theline, reanum)
_TEXT *thefile;
long *theline;
double *reanum;
{
  skipstar(thefile);
  fscanf(thefile->f, "%lg%*[^\n]", reanum);
  getc(thefile->f);
  (*theline)++;
}

Static Void brnumber(thefile, theline, num)
_TEXT *thefile;
long *theline, *num;
{
  skipstar(thefile);
  fscanf(thefile->f, "%ld%*[^\n]", num);
  getc(thefile->f);
  (*theline)++;
}

Static Void brname(thefile, theline, nam)
_TEXT *thefile;
long *theline;
name *nam;
{
  long i;
  Char c_;

  skipstar(thefile);
  nam->length = 0;
  do {
    nam->length++;
    c_ = getc(thefile->f);
    if (c_ == '\n')
      c_ = ' ';
    nam->letters[nam->length - 1] = c_;
  } while (!(P_eoln(thefile->f) || nam->length >= namelength ||
	     nam->letters[nam->length - 1] == ' '));
  if (nam->letters[nam->length - 1] == ' ')
    nam->length--;
  if (nam->length < namelength) {
    for (i = nam->length; i < namelength; i++)
      nam->letters[i] = ' ';
  }
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
}

Static Void brline(thefile, theline, l)
_TEXT *thefile;
long *theline;
line **l;
{
  long i = 0;
  Char acharacter;
  skipstar(thefile);

  while (!P_eoln(thefile->f) && i < linelength) {
    i++;
    acharacter = getc(thefile->f);
    if (acharacter == '\n')
      acharacter = ' ';
    (*l)->letters[i-1] = acharacter;
  }

  if (!P_eoln(thefile->f)) {
    printf("***********************************************\n");
    printf("* WARNING: brline: book line length exceeded\n");
    printf("* linelength > %ld characters\n", (long)linelength);
    printf("* Only %ld characters read from book\n", (long)linelength);
    printf("***********************************************\n");
  }
  (*l)->length = i;
  (*l)->next = NULL;
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
}

Static Void brdirect(thefile, theline, direct)
_TEXT *thefile;
long *theline;
direction *direct;
{
  Char ch;
  skipstar(thefile);
  fscanf(thefile->f, "%c%*[^\n]", &ch);
  getc(thefile->f);
  if (ch == '\n')
    ch = ' ';
  (*theline)++;
  if (ch == '+')
    *direct = plus;
  else
    *direct = minus;
}

Static Void brconfig(thefile, theline, config)
_TEXT *thefile;
long *theline;
configuration *config;
{
  Char ch;
  skipstar(thefile);
  fscanf(thefile->f, "%c%*[^\n]", &ch);
  getc(thefile->f);
  if (ch == '\n')
    ch = ' ';
  (*theline)++;
  if (ch == 'l')
    *config = linear;
  else
    *config = circular;
}

Static Void brnotenumber(thefile, theline, note)
_TEXT *thefile;
long *theline;
line **note;
{
  *note = NULL;
  numbered = false;
  number = 0;
 
  if (P_peek(thefile->f) != 'n')
    return;
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
  if (P_peek(thefile->f) != 'n') {
    skipstar(thefile);
    if (!P_eoln(thefile->f)) {
      if (P_peek(thefile->f) == '#') {
	numbered = true;
	getc(thefile->f);
	fscanf(thefile->f, "%ld", &number);
      }
    }
    do {
      fscanf(thefile->f, "%*[^\n]");
      getc(thefile->f);
      (*theline)++;
    } while (P_peek(thefile->f) != 'n');
    fscanf(thefile->f, "%*[^\n]");
    getc(thefile->f);
    (*theline)++;
    return;
  }
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
}

Static Void brnote(thefile, theline, note)
_TEXT *thefile;
long *theline;
line **note;
{
  line *newnote, *previousnote;
  *note = NULL;
  if (P_peek(thefile->f) != 'n')
    return;
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
  if (P_peek(thefile->f) != 'n') {
    getlineDelila(note);
    newnote = *note;
    while (P_peek(thefile->f) != 'n') {
      brline(thefile, theline, &newnote);
      previousnote = newnote;

      getlineDelila(&newnote->next);
      newnote = newnote->next;
    }

    clearline(&newnote);
    previousnote->next = NULL;
    fscanf(thefile->f, "%*[^\n]");
    getc(thefile->f);
    (*theline)++;
    return;
  }
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
}



Static Void brheader(thefile, theline, hea)
_TEXT *thefile;
long *theline;
header *hea;
{
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
  brname(thefile, theline, &hea->keynam);
  getlineDelila(&hea->fulnam);
  brline(thefile, theline, &hea->fulnam);

  if (readnumber)
    brnotenumber(thefile, theline, &hea->note);
  else
    brnote(thefile, theline, &hea->note);
}

Static Void copyheader(fromhea, tohea)
header fromhea, *tohea;
{
  memcpy(tohea->keynam.letters, fromhea.keynam.letters, sizeof(alpha));
  tohea->keynam.length = fromhea.keynam.length;
  tohea->note = fromhea.note;
  tohea->fulnam = fromhea.fulnam;
}

Static Void brpiekey(thefile, theline, pie)
_TEXT *thefile;
long *theline;
piekey *pie;
{
  brheader(thefile, theline, &pie->hea);
  brreanum(thefile, theline, &pie->mapbeg);
  brconfig(thefile, theline, &pie->coocon);
  brdirect(thefile, theline, &pie->coodir);
  brnumber(thefile, theline, &pie->coobeg);
  brnumber(thefile, theline, &pie->cooend);
  brconfig(thefile, theline, &pie->piecon);
  brdirect(thefile, theline, &pie->piedir);
  brnumber(thefile, theline, &pie->piebeg);
  brnumber(thefile, theline, &pie->pieend);
}

Static Void brdna(thefile, theline, dna)
_TEXT *thefile;
long *theline;
dnastring **dna;
{
  Char ch;
  dnastring *workdna;
  long SET[5];
  long TEMP;

  getdna(dna);
  workdna = *dna;
  ch = getto(thefile, theline, P_addset(P_expset(SET, 0L), 'd'));
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
  ch = getc(thefile->f);
  if (ch == '\n')
    ch = ' ';
  while (ch == '*') {
    ch = getc(thefile->f);
    if (ch == '\n')
      ch = ' ';
    do {
      ch = getc(thefile->f);
      if (ch == '\n')
	ch = ' ';
      if (ch == 't' || ch == 'g' || ch == 'c' || ch == 'a') {
	if (workdna->length == dnamax) {
	  getdna(&workdna->next);
	  workdna = workdna->next;
	}
	workdna->length++;
	TEMP = workdna->length - 1;
	P_clrbits_B(workdna->part, TEMP, 1, 3);
	P_putbits_UB(workdna->part, TEMP, (int)chartobase(ch), 1, 3);
      }
    } while (!P_eoln(thefile->f));
    fscanf(thefile->f, "%*[^\n]");
    getc(thefile->f);
    (*theline)++;
    ch = getc(thefile->f);
    if (ch == '\n')
      ch = ' ';
  }
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
}

Static Void brpiece(thefile, theline, pie)
_TEXT *thefile;
long *theline;
piece **pie;
{
  brpiekey(thefile, theline, &(*pie)->key);
  if (numbered || !skipunnum)
    brdna(thefile, theline, &(*pie)->dna);
  fscanf(thefile->f, "%*[^\n]");
  getc(thefile->f);
  (*theline)++;
}

Static Void brinit(book, theline)
_TEXT *book;
long *theline;
{
  if (*book->name != '\0') {
    if (book->f != NULL)
      book->f = freopen(book->name, "r", book->f);
    else
      book->f = fopen(book->name, "r");
  } else
    rewind(book->f);
  if (book->f == NULL)
    _EscIO2(FileNotFound, book->name);
  RESETBUF(book->f, Char);
  if (!BUFEOF(book->f)) {
    if (P_peek(book->f) != '*') {
      if (P_peek(book->f) != 'h')
	printf(" this is not the first line of a book:\n");
      else
	printf(" bad book:\n");
      putchar(' ');

      while (!(P_eoln(book->f) | BUFEOF(book->f))) {
	putchar(P_peek(book->f));
	getc(book->f);
      }
      putchar('\n');
      halt();
    }
  }

  else {
    printf(" book is empty\n");
    halt();
  }
  freeline = NULL;
  freedna = NULL;
  readnumber = true;
  number = 0;
  numbered = false;
  skipunnum = false;
  *theline = 1;
}

Static Void getpiece(thefile, theline, pie)
_TEXT *thefile;
long *theline;
piece **pie;
{
  Char ch;
  long SET[5];

  ch = getto(thefile, theline, P_addset(P_expset(SET, 0L), 'p'));
  if (ch != ' ') {
    brpiece(thefile, theline, pie);
 
  } else
    clearpiece(pie);
}

Static Void findblank(afile)
_TEXT *afile;
{
  Char ch;

  do {
    ch = getc(afile->f);
    if (ch == '\n')
      ch = ' ';
  } while (ch != ' ');
}

Static Void findnonblank(afile, ch)
_TEXT *afile;
Char *ch;
{
  *ch = ' ';
  while (!BUFEOF(afile->f) && *ch == ' ') {
    *ch = getc(afile->f);
    if (*ch == '\n')
      *ch = ' ';
    if (P_eoln(afile->f)) {
      fscanf(afile->f, "%*[^\n]");
      getc(afile->f);
    }
  }
}

#define maximumrange    20000
#define semicolon       ';'

/* Local variables for align: */
struct LOC_align {
  _TEXT *inst;
  Char ch;
  trigger endcomment, endcurly;
} ;

Local Void skipcomment(f, LINK)
_TEXT *f;
struct LOC_align *LINK;
{
  boolean comment = true;

  resettrigger(&LINK->endcomment);
  while (comment) {
    if (BUFEOF(f->f)) {
      printf("A comment does not end!\n");
      halt();
    }
    if (P_eoln(f->f)) {
      fscanf(f->f, "%*[^\n]");
      getc(f->f);
      continue;
    }

    LINK->ch = getc(f->f);
    if (LINK->ch == '\n')
      LINK->ch = ' ';
    testfortrigger(LINK->ch, &LINK->endcomment);
    if (LINK->endcomment.found) {
      comment = false;
    }
  }
}

Local Void skipcurly(f, LINK)
_TEXT *f;
struct LOC_align *LINK;
{
  boolean comment = true;

  resettrigger(&LINK->endcurly);
  while (comment) {
    if (BUFEOF(f->f)) {
      printf("A comment does not end!\n");
      halt();
    }
    if (P_eoln(f->f)) {
      fscanf(f->f, "%*[^\n]");
      getc(f->f);
      continue;
    }

    LINK->ch = getc(f->f);
    if (LINK->ch == '\n')
      LINK->ch = ' ';
    testfortrigger(LINK->ch, &LINK->endcurly);
    if (LINK->endcurly.found) {
      comment = false;
    }
  }
}

Local Void skipquote(quote, LINK)
trigger quote;
struct LOC_align *LINK;
{
  Char kind;
  kind = quote.seek.letters[0];

  do {
    findnonblank(LINK->inst, &LINK->ch);
  } while (!((LINK->ch == kind) | BUFEOF(LINK->inst->f)));
  if (LINK->ch != kind) {
    printf("end of quote starting with %c not found\n", kind);
    halt();
  }
}

Static Void align(inst_, book, theline, pie, length, alignedbase)
_TEXT *inst_, *book;
long *theline;
piece **pie;
long *length, *alignedbase;
{
  struct LOC_align V;
  long p, p1;
  boolean done = false;
  long thebase;
  boolean indefault = false;
  /*
*/

  trigger gettrigger, defaulttrigger, nametrigger, piecetrigger, settrigger;
  trigger begincomment, begincurly;
  trigger quote1trigger, quote2trigger;
  boolean dotteddone;
  name *WITH;
  V.inst = inst_;
  filltrigger(&defaulttrigger, "default              ");
  filltrigger(&gettrigger, "get                  ");
  filltrigger(&nametrigger, "name                 ");
  filltrigger(&piecetrigger, "piece                ");
  filltrigger(&settrigger, "set                  ");
  filltrigger(&begincomment, "(*                   ");
  filltrigger(&V.endcomment, "*)                   ");
  filltrigger(&begincurly, "{                    ");
  filltrigger(&V.endcurly, "}                    ");
  filltrigger(&quote1trigger, "'                    ");
  filltrigger(&quote2trigger, "\"                    ");
  resettrigger(&defaulttrigger);
  resettrigger(&gettrigger);
  resettrigger(&nametrigger);
  resettrigger(&piecetrigger);
  resettrigger(&settrigger);
  resettrigger(&begincomment);
  resettrigger(&begincurly);
  resettrigger(&quote1trigger);
  resettrigger(&quote2trigger);

  if (BUFEOF(book->f))
    return;
  getpiece(book, theline, pie);
  if (BUFEOF(book->f))
    return;
  *length = pietoint((*pie)->key.pieend, *pie);

  while (!done) {
    if (BUFEOF(V.inst->f)) {
      *alignedbase = 1;
      done = true;
      break;
    }
    if (P_eoln(V.inst->f)) {
      fscanf(V.inst->f, "%*[^\n]");
      getc(V.inst->f);
      continue;
    }

    V.ch = getc(V.inst->f);

    if (V.ch == '\n')
      V.ch = ' ';
    testfortrigger(V.ch, &begincomment);
    testfortrigger(V.ch, &begincurly);
    if (begincomment.found || begincurly.found) {
      if (V.ch == '*') {
	skipcomment(V.inst, &V);
	resettrigger(&begincomment);
      } else {
	resettrigger(&begincurly);
	skipcurly(V.inst, &V);
      }
      continue;
    }
    testfortrigger(V.ch, &gettrigger);
    if (gettrigger.found) {
      findnonblank(V.inst, &V.ch);
      findblank(V.inst);
      fscanf(V.inst->f, "%ld", &thebase);

      *alignedbase = pietoint(thebase, *pie);

      done = true;
    }

    testfortrigger(V.ch, &quote1trigger);
    if (quote1trigger.found)
      skipquote(quote1trigger, &V);

    testfortrigger(V.ch, &quote2trigger);
    if (quote2trigger.found)
      skipquote(quote2trigger, &V);

    testfortrigger(V.ch, &defaulttrigger);
    if (defaulttrigger.found) {
      indefault = true;
      resettrigger(&defaulttrigger);
    }
    if (V.ch == semicolon)
      indefault = false;

    testfortrigger(V.ch, &settrigger);
    if (settrigger.found) {
      indefault = true;
      resettrigger(&settrigger);
    }
    if (V.ch == semicolon)
      indefault = false;

    testfortrigger(V.ch, &piecetrigger);
    if (indefault)
      continue;

    if (!piecetrigger.found)
      continue;
    skipblanks(V.inst);
    WITH = &(*pie)->key.hea.keynam;
    p = 1;
    dotteddone = false;
    while (!dotteddone) {
      if (P_eoln(V.inst->f)) {
	dotteddone = true;
	break;
      }
      V.ch = getc(V.inst->f);

      if (V.ch == '\n')
	V.ch = ' ';
     if (V.ch == '.')
	dotteddone = true;
      if (WITH->letters[p-1] == '.')
	dotteddone = true;
   
      if (WITH->letters[p-1] != V.ch && !dotteddone && V.ch != ';') {
	printf("The piece name in the book: \n");
/* p2c: ri.p, line 2542: Note:
 * Format for packed-array-of-char will work only if width < length [321] */
	printf("%.*s\n", WITH->length, WITH->letters);
	printf("does not match the inst file piece name:\n");

	for (p1 = 0; p1 <= p - 2; p1++)
	  putchar(WITH->letters[p1]);

	putchar(V.ch);
	done = P_eoln(V.inst->f);
	while (!done) {
	  done = P_eoln(V.inst->f);
	  if (done)
	    break;
	  V.ch = getc(V.inst->f);
	  if (V.ch == '\n')
	    V.ch = ' ';
	  if (V.ch == ' ' || V.ch == ';')
	    done = true;
	  if (!done)
	    putchar(V.ch);
	}
	putchar('\n');

	for (p1 = 1; p1 < p; p1++)
	  putchar(' ');
	printf("^\n");
	halt();
      }
      p++;
      if (p > WITH->length) {
	dotteddone = true;

      }
    }
  }

  if (*alignedbase > -maximumrange && *alignedbase <= *length + maximumrange)
    return;
  printf(" In procedure align:\n");
  printf(" read in base was %ld\n", thebase);
  printf(" in internal coordinates: %ld\n", *alignedbase);
  printf(" maximum range was %ld\n", (long)maximumrange);
  printf(" piece length was %ld\n", *length);
  WITH = &(*pie)->key.hea.keynam;
/* p2c: ri.p, line 2589: Note:
 * Format for packed-array-of-char will work only if width < length [321] */
  printf(" piece name: %.*s\n", WITH->length, WITH->letters);
  printf(" piece number: %ld\n", number);
  printf(" aligned base is too far away... see the code\n");
  halt();
}

#undef maximumrange
#undef semicolon
#define maximumrange    20000

Static Void maxminalignment(inst, book, theline, fromparam, toparam,
			    alignmenttype)
_TEXT *inst, *book;
long *theline, *fromparam, *toparam;
Char alignmenttype;
{
  long distance;
  piece *pie;
  long length, alignedbase;

  pie = (piece *)Malloc(sizeof(piece));
  *fromparam = LONG_MAX;
  *toparam = -LONG_MAX;

  if (*book->name != '\0') {
    if (book->f != NULL)
      book->f = freopen(book->name, "r", book->f);
    else
      book->f = fopen(book->name, "r");
  } else
    rewind(book->f);
  if (book->f == NULL)
    _EscIO2(FileNotFound, book->name);
  RESETBUF(book->f, Char);
  if (*inst->name != '\0') {
    if (inst->f != NULL)
      inst->f = freopen(inst->name, "r", inst->f);
    else
      inst->f = fopen(inst->name, "r");
  } else
    rewind(inst->f);
  if (inst->f == NULL)
    _EscIO2(FileNotFound, inst->name);
  RESETBUF(inst->f, Char);
  while (!BUFEOF(book->f)) {
    switch (alignmenttype) {

    case 'i':
      align(inst, book, theline, &pie, &length, &alignedbase);
      break;
    case 'b':
    case 'f':
      getpiece(book, theline, &pie);
      length = piecelength(pie);
      break;
    }

    if (BUFEOF(book->f))
      break;
    switch (alignmenttype) {
    case 'f':
      alignedbase = 0;
      *fromparam = 1;
      distance = length - alignedbase;
      if (*toparam < distance)
	*toparam = distance;
      break;
    case 'i':
      distance = 1 - alignedbase;
      if (*fromparam > distance)
     	*fromparam = distance;
      distance = length - alignedbase;
      if (*toparam < distance)
	*toparam = distance;
      break;
    case 'b':
      alignedbase = pietoint(0L, pie);
      distance = 1 - alignedbase;
      if (*fromparam > distance)
	*fromparam = distance;
      distance = length - alignedbase;
      if (*toparam < distance)
	*toparam = distance;
      break;
    }

    clearpiece(&pie);
  }

  if (*toparam - *fromparam > maximumrange) {
    printf(" in procedure maxminalignment:\n");
    printf(" alignedbase = %ld\n", alignedbase);
    printf(" fromparameter = %ld\n", *fromparam);
    printf(" toparameter = %ld\n", *toparam);
    printf(" this exceeds the maximum range allowed (%ld)\n",
	   (long)maximumrange);
    printf(" see notes in the procedure. \n");
    halt();
  }

  if (*book->name != '\0') {
    if (book->f != NULL)
      book->f = freopen(book->name, "r", book->f);
    else
      book->f = fopen(book->name, "r");
  } else
    rewind(book->f);
  if (book->f == NULL)
    _EscIO2(FileNotFound, book->name);
  RESETBUF(book->f, Char);
  if (*inst->name != '\0') {
    if (inst->f != NULL)
      inst->f = freopen(inst->name, "r", inst->f);
    else
      inst->f = fopen(inst->name, "r");
  } else
    rewind(inst->f);
  if (inst->f == NULL)
    _EscIO2(FileNotFound, inst->name);
  RESETBUF(inst->f, Char);
  Free(pie);
}

#undef maximumrange

Static boolean withinalignment(alignedposition, alignedbase, length)
long alignedposition, alignedbase, length;
{
  long p;
  p = alignedposition + alignedbase;
  return (p > 0 && p <= length);
}

Static base getbase(position, pie)
long position;
piece *pie;
{
  dnastring *workdna;
  long p, spot, thelength;
  thelength = piecelength(pie);
  while (position < 1)
    position += thelength;
  while (position > thelength)
    position -= thelength;

  workdna = pie->dna;
  p = workdna->length;
  while (position > p) {
    
    workdna = workdna->next;
    if (workdna == NULL) {
      printf("error in function getbase!\n");
      halt();
    }
    p += workdna->length;
  }
  if (true) {
    spot = workdna->length - p + position;
  
    if (spot <= 0) {
      printf("error in getbase, spot (= %ld) must be positive\n", spot);
      halt();
    }
    if (spot > workdna->length) {
      printf("error in getbase, spot (=%ld) must be less than length (=%d)\n",
	     spot, workdna->length);
      halt();
    }
  
    return ((base)P_getbits_UB(workdna->part, spot - 1, 1, 3));
  }
  printf("error in getbase: request off end of piece\n");
  halt();
}

Static Void readawaveparameter(afile, wp)
_TEXT *afile;
waveparam *wp;
{
  fscanf(afile->f, "%c%*[^\n]", &wp->extreme);
  getc(afile->f);
  if (wp->extreme == '\n')
    wp->extreme = ' ';
  fscanf(afile->f, "%lg%*[^\n]", &wp->wavelocation);
  getc(afile->f);
  fscanf(afile->f, "%lg%*[^\n]", &wp->wavebit);
  getc(afile->f);
  fscanf(afile->f, "%lg%*[^\n]", &wp->waveamplitude);
  getc(afile->f);
  fscanf(afile->f, "%lg%*[^\n]", &wp->wavelength);
  getc(afile->f);
  if (wp->wavelength <= 0.0) {
    printf("wave parameters: wavelength must be positive\n");
    halt();
  }
  if (BUFEOF(afile->f)) {
    wp->dashon = 0.0;
    wp->dashoff = 0.0;
    wp->dashoffset = 0.0;
    wp->thickness = 0.0;
    return;
  }

  if (P_peek(afile->f) != 'd') {
    fscanf(afile->f, "%lg%*[^\n]", &wp->dashon);
    getc(afile->f);
    wp->dashoff = wp->dashon;
    wp->dashoffset = 0.0;
  } else {
    getc(afile->f);
    fscanf(afile->f, "%lg%lg%lg%*[^\n]", &wp->dashon, &wp->dashoff,
	   &wp->dashoffset);
    getc(afile->f);

  }
  if (BUFEOF(afile->f))
    wp->thickness = 0.0;
  else {
    fscanf(afile->f, "%lg%*[^\n]", &wp->thickness);
    getc(afile->f);
  }
}

/* Local variables for readwaveparameters: */
struct LOC_readwaveparameters {
  _TEXT *afile;
  boolean done;
} ;

Local Void waystoend(LINK)
struct LOC_readwaveparameters *LINK;
{
  boolean clear = false;

  if (BUFEOF(LINK->afile->f))
    LINK->done = true;
  if (!LINK->done) {
    while (!clear && !LINK->done) {
      if (BUFEOF(LINK->afile->f)) {
	LINK->done = true;
	clear = true;
      } else if (P_peek(LINK->afile->f) == '*') {
	fscanf(LINK->afile->f, "%*[^\n]");
	getc(LINK->afile->f);
      } else
	clear = true;
    }
  }
  if (!LINK->done) {
    if (P_eoln(LINK->afile->f))
      LINK->done = true;
  }
  if (LINK->done)
    return;
  if (P_peek(LINK->afile->f) != '.')
    return;
  fscanf(LINK->afile->f, "%*[^\n]");
  getc(LINK->afile->f);
  LINK->done = true;
}

Static Void readwaveparameters(afile_, w)
_TEXT *afile_;
waveparam **w;
{
  struct LOC_readwaveparameters V;
  boolean morethanone = false;
  waveparam *p;

  V.afile = afile_;
  V.done = false;
  *w = NULL;
  waystoend(&V);
  if (V.done) {
    *w = NULL;
    return;
  }
  *w = (waveparam *)Malloc(sizeof(waveparam));
  p = *w;
  while (!V.done) {
    waystoend(&V);
    if (V.done) {
      p->next = NULL;
      continue;
    }
    if (P_peek(V.afile->f) == '*') {
      fscanf(V.afile->f, "%*[^\n]");
      getc(V.afile->f);
      continue;
    }
    if (morethanone) {
      p->next = (waveparam *)Malloc(sizeof(waveparam));
      p = p->next;
    }
    readawaveparameter(V.afile, p);
    morethanone = true;
  }
}
#define wid             4

Static Void writewaveparameters(afile, w)
_TEXT *afile;
waveparam *w;
{
  waveparam *i = w;
  waveparam *WITH;

  while (i != NULL) {
    WITH = i;
    fprintf(afile->f,
      "%c  extreme: char; h or l, the high or low extreme to be defined\n",
      WITH->extreme);
    fprintf(afile->f,
      "%*.1f  wavelocation: real; the location in bases of the extreme\n",
      wid, WITH->wavelocation);
    fprintf(afile->f,
	    "%*.1f  wavebit: real; the location in bits of the extreme\n",
	    wid, WITH->wavebit);
    fprintf(afile->f,
	    "%*.1f  waveamplitude: real; the amplitude of the wave in bits\n",
	    wid, WITH->waveamplitude);
    fprintf(afile->f,
	    "%*.1f  wavelength: real; the wave length of the wave in bases\n",
	    wid, WITH->wavelength);
  
    fprintf(afile->f,
	    "%*.1f %*.1f %*.1f dashon, dashoff, dashoffset (in bases)\n",
	    wid, WITH->dashon, wid, WITH->dashoff, wid, WITH->dashoffset);
    fprintf(afile->f,
      "%*.1f  thickness: real; the thickness of the cosine wave.  <=0 means default\n",
      wid, WITH->thickness);
    i = i->next;
  }
  fprintf(afile->f, ".\n");
}
#undef wid

Static Void putriblmatrix(afile, matrix)
_TEXT *afile;
ribltype *matrix;
{
  long lindex, FORLIM;

  if (matrix == NULL)
    return;
  fprintf(afile->f, "ribl");
  putc(' ', afile->f);
  writequotestring(afile, matrix->riblname);
  putc('\n', afile->f);

  writestringlines(afile, matrix->riblheader);
  fprintf(afile->f, "%*ld %*ld frombase, tobase\n",
	  nfield, matrix->frombase, nfield, matrix->tobase);
  FORLIM = matrix->tobase;
  for (lindex = matrix->frombase; lindex <= FORLIM; lindex++) {
    fprintf(afile->f, "  %*.*f %*.*f %*.*f %*.*f %*ld",
	    infofield, infodecim, matrix->data[0][lindex - minribl],
	    infofield, infodecim, matrix->data[(long)c - (long)a]
	    [lindex - minribl], infofield, infodecim,
	    matrix->data[(long)g - (long)a][lindex - minribl], infofield,
	    infodecim, matrix->data[(long)t - (long)a][lindex - minribl],
	    nfield, lindex);
    fprintf(afile->f, " %*ld %*ld %*ld %*ld\n",
	    nfield, matrix->numbers[0][lindex - minribl], nfield,
	    matrix->numbers[(long)c - (long)a][lindex - minribl], nfield,
	    matrix->numbers[(long)g - (long)a][lindex - minribl], nfield,
	    matrix->numbers[(long)t - (long)a][lindex - minribl]);
  }
  fprintf(afile->f, "*\n");
  fprintf(afile->f, "%*.*f bits = mean (Rsequence of selected region)\n",
	  infofield, infodecim, matrix->mean);
  fprintf(afile->f, "%*.*f bits = standard deviation\n",
	  infofield, infodecim, matrix->stdev);
  fprintf(afile->f, "*\n");
  fprintf(afile->f, "%*.*f bits = Ri of consensus sequence from %ld to %ld\n",
	  infofield, infodecim, matrix->consensus, matrix->frombase,
	  matrix->tobase);
  fprintf(afile->f,
	  "%*.*f bits = Ri of anticonsensus sequence from %ld to %ld\n",
	  infofield, infodecim, matrix->anticonsensus, matrix->frombase,
	  matrix->tobase);
  fprintf(afile->f, "*\n");
  fprintf(afile->f,
	  "%*.*f bits = average Ri for random sequence from %ld to %ld\n",
	  infofield, infodecim, matrix->averageRi, matrix->frombase,
	  matrix->tobase);
  fprintf(afile->f, "*\n");
  fprintf(afile->f, "%ld n, number of sequences used to create the matrix\n",
	  matrix->n);
  fprintf(afile->f, "*\n");
  switch (matrix->symmetry) {
  case 'a':
    fprintf(afile->f, "asymmetric");
    break;
  case 'e':
    fprintf(afile->f, "even");
    break;
  case 'o':
    fprintf(afile->f, "odd");
    break;
  }
  fprintf(afile->f, " symmetry of the matrix\n");
  fprintf(afile->f, "*\n");
  fprintf(afile->f, "%*.*f Ri bound: lower bound on Ri\n",
	  infofield, infodecim, matrix->Ribound);
  fprintf(afile->f, "%*.*f Z bound: lower bound on Z\n",
	  infofield, infodecim, matrix->Zbound);
  fprintf(afile->f, "%*.*f P bound: upper probability\n",
	  infofield, infodecim, matrix->Pbound);
  fprintf(afile->f, "*\n");
  writewaveparameters(afile, matrix->waves);
  putc('\n', afile->f);
}


Static Void Riheader(infile, book, c_, outfile)
_TEXT *infile, *book;
Char c_;
_TEXT *outfile;
{
  long index;

  if (*infile->name != '\0') {
    if (infile->f != NULL)
      infile->f = freopen(infile->name, "r", infile->f);
    else
      infile->f = fopen(infile->name, "r");
  } else
    rewind(infile->f);
  if (infile->f == NULL)
    _EscIO2(FileNotFound, infile->name);
  RESETBUF(infile->f, Char);

  fprintf(outfile->f, "%c Ri %4.2f\n", c_, version);
  fprintf(outfile->f, "%c\n", c_);
  fprintf(outfile->f, "%c Ri(b,l) table is from:\n", c_);

  for (index = 1; index <= 3; index++) {
    putc(c_, outfile->f);
    copyaline(infile, outfile);
  }

  fprintf(outfile->f, "%c\n", c_);

  if (*book->name != '\0') {
    if (book->f != NULL)
      book->f = freopen(book->name, "r", book->f);
    else
      book->f = fopen(book->name, "r");
  } else
    rewind(book->f);
  if (book->f == NULL)
    _EscIO2(FileNotFound, book->name);
  RESETBUF(book->f, Char);
  fprintf(outfile->f, "%c BOOK/INST sequences are from:\n", c_);
  copyaline(book, outfile);
  fprintf(outfile->f, "%c ", c_);
  if (*inst.name != '\0') {
    if (inst.f != NULL)
      inst.f = freopen(inst.name, "r", inst.f);
    else
      inst.f = fopen(inst.name, "r");
  } else
    rewind(inst.f);
  if (inst.f == NULL)
    _EscIO2(FileNotFound, inst.name);
  RESETBUF(inst.f, Char);
  if (!BUFEOF(inst.f))
    copyaline(&inst, outfile);
  else
    fprintf(outfile->f, "(no instructions)\n");
  fprintf(outfile->f, "%c\n", c_);
}

Static Void readrsrange(rsdata, r)
_TEXT *rsdata;
rstype *r;
{
  long index;
  Char skip;

  for (index = 1; index <= 11; index++) {
    fscanf(rsdata->f, "%*[^\n]");
    getc(rsdata->f);
  }
  fscanf(rsdata->f, "%c%ld%ld%*[^\n]", &skip, &r->rstart, &r->rstop);
  getc(rsdata->f);

  if (skip == '\n')
    skip = ' ';
}

Static Void getrsbegin(infile)
_TEXT *infile;
{
  Char ch;
  trigger begindata;

  filltrigger(&begindata, "l    a    c    g    t");
  resettrigger(&begindata);

  if (*infile->name != '\0') {
    if (infile->f != NULL)
      infile->f = freopen(infile->name, "r", infile->f);
    else
      infile->f = fopen(infile->name, "r");
  } else
    rewind(infile->f);
  if (infile->f == NULL)
    _EscIO2(FileNotFound, infile->name);
  RESETBUF(infile->f, Char);
  while (!begindata.found) {
    if (P_eoln(infile->f)) {
      fscanf(infile->f, "%*[^\n]");
      getc(infile->f);
    }
    if (BUFEOF(infile->f)) {
      printf("beginning of data not found\n");
      halt();
    }
    ch = getc(infile->f);
    if (ch == '\n')
      ch = ' ';
    testfortrigger(ch, &begindata);
  }
  fscanf(infile->f, "%*[^\n]");
  getc(infile->f);
}

Static Void readrsdata(rsdata, rdata)
_TEXT *rsdata;
rstype *rdata;
{
  fscanf(rsdata->f, "%ld%ld%ld%ld%ld%lg%lg%lg%lg%ld%lg", &rdata->l,
	 &rdata->nal, &rdata->ncl, &rdata->ngl, &rdata->ntl, &rdata->rsl,
	 &rdata->rs, &rdata->varhnb, &rdata->sumvar, &rdata->nl,
	 &rdata->ehnb);

  while (P_peek(rsdata->f) == ' ')
    getc(rsdata->f);
  fscanf(rsdata->f, "%c%*[^\n]", &rdata->flag);
  getc(rsdata->f);
 
  if (rdata->flag == '\n')
    rdata->flag = ' ';
}

Static double Ricalc(ehnb, nxl, nl, niot, ricalctype)
double ehnb;
long nxl, nl;
double niot;
Char ricalctype;
{
  double Result;

  switch (ricalctype) {
  case 'l':
    Result = 2.0 + log((nxl + 1.0) / (nl + 2)) / log(2.0);
    break;
  case 's':
  case 'b':
  case 'n':
    if (nl <= 0) {
      printf(
	" Ricalc: a position in the data has less than 1 example! ehnb = %8.5f nxl = %ld nl = %ld\n",
	ehnb, nxl, nl);
      halt();
    }
    if (nxl < 1) {
      if (ricalctype == 'b')
	Result = log(1 / (nl + niot)) / log(2.0);
      else {
	if (niot > 1.0) {
	  Result = ehnb + log(1 / (nl + niot)) / log(2.0);
	} else
	  Result = niot;
      }
    } else
      Result = ehnb + log((double)nxl / nl) / log(2.0);
    break;
  }
  return Result;
}

Static double min(a_, b)
double a_, b;
{
  if (a_ < b)
    return a_;
  else
    return b;
}

Static double max(a_, b)
double a_, b;
{
  if (a_ > b)
    return a_;
  else
    return b;
}

/* Local variables for computerandomav: */
struct LOC_computerandomav {
  rblarray Riblmatrix;
  double sum;
  long count;
} ;

Local Void addin(l, b, LINK)
long l;
base b;
struct LOC_computerandomav *LINK;
{
  if (LINK->Riblmatrix[(long)b - (long)a][l - minribl] > defnegativeinfinity) {
    LINK->count++;
    LINK->sum += LINK->Riblmatrix[(long)b - (long)a][l - minribl];
  }
}

Static double computerandomav(Riblmatrix_, thefrom, theto)
double (*Riblmatrix_)[maxribl - minribl + 1];
long thefrom, theto;
{
  struct LOC_computerandomav V;
  double average = 0.0;
  long position;

  memcpy(V.Riblmatrix, Riblmatrix_, sizeof(rblarray));
  for (position = thefrom; position <= theto; position++) {
    V.sum = 0.0;
    V.count = 0;
    addin(position, a, &V);
    addin(position, c, &V);
    addin(position, g, &V);
    addin(position, t, &V);

    if (V.count > 0)
      average += V.sum / V.count;
  }
  return average;
 
}

Static Char matrixsymmetry(matrix, fromwanted, towanted)
double (*matrix)[maxribl - minribl + 1];
long fromwanted, towanted;
{
  base b;
  long lindex, length;
  boolean symmetric = true;
  length = towanted - fromwanted + 1;
  lindex = fromwanted;

  while (lindex <= towanted && symmetric) {

    for (b = a; (long)b <= (long)t; b = (base)((long)b + 1)) {
      if (matrix[(long)b - (long)a]
	  [lindex - minribl] != matrix[(long)complement(b) - (long)a]
	  [towanted - lindex + fromwanted - minribl])
	symmetric = false;

    }
    lindex++;
  }
  if (symmetric) {
    if ((length & 1) == 0)
      return 'e';
    else
      return 'o';
  } else
    return 'a';
}

/* Local variables for readparameters: */
struct LOC_readparameters {
  _TEXT *rip;
  double parameterversion;
  _TEXT hold;
} ;

Local Void die(LINK)
struct LOC_readparameters *LINK;
{
  printf("missing parameter\n");
  halt();
}

Local Void upgradefrom233tonow(LINK)
struct LOC_readparameters *LINK;
{
  printf("FIXING THE PARAMETER file, rip!\n");
  printf("EDIT THE rip FILE TO GIVE YOUR MODEL A NEW NAME\n");
  if (*LINK->hold.name != '\0') {
    if (LINK->hold.f != NULL)
      LINK->hold.f = freopen(LINK->hold.name, "w", LINK->hold.f);
    else
      LINK->hold.f = fopen(LINK->hold.name, "w");
  } else {
    if (LINK->hold.f != NULL)
      rewind(LINK->hold.f);
    else
      LINK->hold.f = tmpfile();
  }
  if (LINK->hold.f == NULL)
    _EscIO2(FileNotFound, LINK->hold.name);
  SETUPBUF(LINK->hold.f, Char);
  if (*LINK->rip->name != '\0') {
    if (LINK->rip->f != NULL)
      LINK->rip->f = freopen(LINK->rip->name, "r", LINK->rip->f);
    else
      LINK->rip->f = fopen(LINK->rip->name, "r");
  } else
    rewind(LINK->rip->f);
  if (LINK->rip->f == NULL)
    _EscIO2(FileNotFound, LINK->rip->name);
  RESETBUF(LINK->rip->f, Char);
  fscanf(LINK->rip->f, "%*[^\n]");
  getc(LINK->rip->f);
  while (!BUFEOF(LINK->rip->f))
    copyaline(LINK->rip, &LINK->hold);
  if (*LINK->rip->name != '\0') {
    if (LINK->rip->f != NULL)
      LINK->rip->f = freopen(LINK->rip->name, "w", LINK->rip->f);
    else
      LINK->rip->f = fopen(LINK->rip->name, "w");
  } else {
    if (LINK->rip->f != NULL)
      rewind(LINK->rip->f);
    else
      LINK->rip->f = tmpfile();
  }
  if (LINK->rip->f == NULL)
    _EscIO2(FileNotFound, LINK->rip->name);
  SETUPBUF(LINK->rip->f, Char);
  fprintf(LINK->rip->f,
    "%4.2f          version of ri that this parameter file is designed for.\n",
    version);
  fprintf(LINK->rip->f,
    "\"NAME_THIS_MODEL_IN_THE_rip_FILE_AND_RERUN_ri\"        name of the ribl matrix\n");
  if (*LINK->hold.name != '\0') {
    if (LINK->hold.f != NULL)
      LINK->hold.f = freopen(LINK->hold.name, "r", LINK->hold.f);
    else
      LINK->hold.f = fopen(LINK->hold.name, "r");
  } else
    rewind(LINK->hold.f);
  if (LINK->hold.f == NULL)
    _EscIO2(FileNotFound, LINK->hold.name);
  RESETBUF(LINK->hold.f, Char);
  while (!BUFEOF(LINK->hold.f))
    copyaline(&LINK->hold, LINK->rip);

  fprintf(LINK->rip->f,
    "-5000         Ribound: real; the Ri boundary for this definition\n");
  fprintf(LINK->rip->f,
	  "100           Zbound:  real; the Z boundary for this definition\n");
  fprintf(LINK->rip->f,
    "1.00          Pbound:  real; the probability boundary for this definition\n");

  if (*LINK->rip->name != '\0') {
    if (LINK->rip->f != NULL)
      LINK->rip->f = freopen(LINK->rip->name, "r", LINK->rip->f);
    else
      LINK->rip->f = fopen(LINK->rip->name, "r");
  } else
    rewind(LINK->rip->f);
  if (LINK->rip->f == NULL)
    _EscIO2(FileNotFound, LINK->rip->name);
  RESETBUF(LINK->rip->f, Char);
  fscanf(LINK->rip->f, "%lg%*[^\n]", &LINK->parameterversion);
  getc(LINK->rip->f);
  if (LINK->parameterversion != version) {
    printf("utter failure of upgrade attempt!\n");
    halt();
  }
}

Static Void readparameters(rip_, thename, thefrom, theto, column, lowerRi,
			   upperRi, lowerValue, upperValue, printsequ,
			   printrixyin, partials, niot, ricalctype,
			   alignmenttype, Ribound, Zbound, Pbound)
_TEXT *rip_;
stringDelila *thename;
long *thefrom, *theto, *column;
double *lowerRi, *upperRi, *lowerValue, *upperValue;
boolean *printsequ, *printrixyin;
Char *partials;
double *niot;
Char *ricalctype, *alignmenttype;
double *Ribound, *Zbound, *Pbound;
{
  struct LOC_readparameters V;
  _TEXT TEMP;

  V.rip = rip_;
  V.hold.f = NULL;
  *V.hold.name = '\0';
  if (*V.rip->name != '\0') {
    if (V.rip->f != NULL)
      V.rip->f = freopen(V.rip->name, "r", V.rip->f);
    else
      V.rip->f = fopen(V.rip->name, "r");
  } else
    rewind(V.rip->f);
  if (V.rip->f == NULL)
    _EscIO2(FileNotFound, V.rip->name);
  RESETBUF(V.rip->f, Char);

  fscanf(V.rip->f, "%lg%*[^\n]", &V.parameterversion);
  getc(V.rip->f);
  if (V.parameterversion < updateversion) {
    printf("You have an old parameter file!\n");
    if (V.parameterversion == 2.33)
      upgradefrom233tonow(&V);
    else
      halt();
  }

  if (BUFEOF(V.rip->f)) {
    printf("missing From-To parameters\n");
    halt();
  }

  readquotestring(V.rip, thename);
  fscanf(V.rip->f, "%*[^\n]");
  getc(V.rip->f);
  TEMP.f = stdout;
  *TEMP.name = '\0';
  writequotestring(&TEMP, *thename);
  putchar('\n');

  fscanf(V.rip->f, "%ld%ld%*[^\n]", thefrom, theto);
  getc(V.rip->f);

  if (*thefrom > *theto) {
    printf("thefrom (=%ld) must be less than TO (=%ld) for Ribl\n",
	   *thefrom, *theto);
    halt();
  }

  if (BUFEOF(V.rip->f)) {
    printf("missing column parameter\n");
    halt();
  }

  fscanf(V.rip->f, "%ld%*[^\n]", column);
  getc(V.rip->f);
  if (*column < 1) {
    printf("column parameter must be positive\n");
    halt();
  }

  if (BUFEOF(V.rip->f)) {
    printf("You are missing the Ri bound parameters\n");
    halt();
  }

  if (P_peek(V.rip->f) == 'a') {
    *lowerRi = -LONG_MAX;
    *upperRi = LONG_MAX;
    fscanf(V.rip->f, "%*[^\n]");
    getc(V.rip->f);
  } else {
    fscanf(V.rip->f, "%lg%lg%*[^\n]", lowerRi, upperRi);
    getc(V.rip->f);
  }

  if (BUFEOF(V.rip->f)) {
    printf("You are missing the Value bound parameters\n");
    halt();
  }

  if (P_peek(V.rip->f) == 'a') {
    *lowerValue = -LONG_MAX;
    *upperValue = LONG_MAX;
    fscanf(V.rip->f, "%*[^\n]");
    getc(V.rip->f);
  } else {
    fscanf(V.rip->f, "%lg%lg%*[^\n]", lowerValue, upperValue);
    getc(V.rip->f);
  }

  if (BUFEOF(V.rip->f)) {
    printf("You are missing the selection parameter\n");
    halt();
  }

  if (P_peek(V.rip->f) == 'p')
    *printsequ = true;
  else
    *printsequ = false;
  fscanf(V.rip->f, "%*[^\n]");

  getc(V.rip->f);
  if (BUFEOF(V.rip->f))
    die(&V);
  if (P_peek(V.rip->f) == 'p')
    *printrixyin = true;
  else
    *printrixyin = false;
  fscanf(V.rip->f, "%*[^\n]");

  getc(V.rip->f);
  if (BUFEOF(V.rip->f))
    die(&V);
  fscanf(V.rip->f, "%c%*[^\n]", partials);
  getc(V.rip->f);
  if (*partials == '\n')
    *partials = ' ';
  if (*partials != 'n' && *partials != 'i')
    *partials = '-';

  if (BUFEOF(V.rip->f))
    die(&V);
  if ((P_peek(V.rip->f) == 's') | (P_peek(V.rip->f) == 'b') |
      (P_peek(V.rip->f) == 'n')) {
    *ricalctype = getc(V.rip->f);
    if (*ricalctype == '\n')
      *ricalctype = ' ';
    fscanf(V.rip->f, "%lg%*[^\n]", niot);
    getc(V.rip->f);
    if (*niot < 0.0) {
      printf("t must be non-negative\n");
      halt();
    }
  } else if (P_peek(V.rip->f) == 'l') {
    fscanf(V.rip->f, "%c%*[^\n]", ricalctype);
    getc(V.rip->f);
    if (*ricalctype == '\n')
      *ricalctype = ' ';
    *niot = 0.0;
  } else {
    if (P_peek(V.rip->f) != '-' && P_peek(V.rip->f) != 'n' &&
	P_peek(V.rip->f) != '9' && P_peek(V.rip->f) != '8' &&
	P_peek(V.rip->f) != '7' && P_peek(V.rip->f) != '6' &&
	P_peek(V.rip->f) != '5' && P_peek(V.rip->f) != '4' &&
	P_peek(V.rip->f) != '3' && P_peek(V.rip->f) != '2' &&
	P_peek(V.rip->f) != '1' && P_peek(V.rip->f) != '0') {
      printf("niot must be in \"rlbn-\" or a digit\n");
      halt();
    }
    if (P_peek(V.rip->f) == 'n')
      getc(V.rip->f);
    *ricalctype = 'n';
    fscanf(V.rip->f, "%lg%*[^\n]", niot);
    getc(V.rip->f);

  }

  if (BUFEOF(V.rip->f))
    die(&V);

  fscanf(V.rip->f, "%c%*[^\n]", alignmenttype);
  getc(V.rip->f);
  if (*alignmenttype == '\n')
    *alignmenttype = ' ';
  if (*alignmenttype != 'b' && *alignmenttype != 'i' && *alignmenttype != 'f') {
    printf("alignment type inst must be f, b, or i\n");
    halt();
  }

  if (BUFEOF(V.rip->f))
    die(&V);
  fscanf(V.rip->f, "%lg%*[^\n]", Ribound);
  getc(V.rip->f);

  if (BUFEOF(V.rip->f))
    die(&V);
  fscanf(V.rip->f, "%lg%*[^\n]", Zbound);
  getc(V.rip->f);

  if (BUFEOF(V.rip->f))
    die(&V);
  fscanf(V.rip->f, "%lg%*[^\n]", Pbound);
  getc(V.rip->f);

  if (V.hold.f != NULL)
    fclose(V.hold.f);
}

Static Void writeparameters(fout, thefrom, theto, column, lowerRi, upperRi,
			    lowerValue, upperValue, printsequ, printrixyin,
			    partials, niot, ricalctype, alignmenttype)
_TEXT *fout;
long thefrom, theto, column;
double lowerRi, upperRi, lowerValue, upperValue;
boolean printsequ, printrixyin;
Char partials;
double niot;
Char ricalctype, alignmenttype;
{
  fprintf(fout->f, "* PARAMETERS FOR Ri:\n");
  fprintf(fout->f, "* %ld %ld from-to\n", thefrom, theto);
  fprintf(fout->f, "* %ld column of value file\n", column);
  fprintf(fout->f, "* %*.*f %*.*f lowest to highest Ri selected\n",
	  infofield, infodecim, lowerRi, infofield, infodecim, upperRi);
  fprintf(fout->f, "* %*.*f %*.*f lowest to highest Value selected\n",
	  infofield, infodecim, lowerValue, infofield, infodecim, upperValue);
  fprintf(fout->f, "* ");
  if (!printsequ)
    fprintf(fout->f, "not");
  else
    fprintf(fout->f, "   ");
  fprintf(fout->f, " printing sequences to sequ\n");

  fprintf(fout->f, "* ");
  if (!printrixyin)
    fprintf(fout->f, "not");
  else
    fprintf(fout->f, "   ");
  fprintf(fout->f, " printing sequences to rixyin\n");

  fprintf(fout->f, "* ");
  switch (partials) {
  case 'n':
    fprintf(fout->f, "n: no line printed when partial site\n");
    break;
  case 'i':
    fprintf(fout->f,
      "i: keep line printed when partial site, but force Ri = -infinity\n");
    break;
  case '-':
    fprintf(fout->f, "-: whole line printed when partial site\n");
    break;
  }

  fprintf(fout->f, "* ");
  if (ricalctype == 's' || ricalctype == 'b') {
    fprintf(fout->f,
      " using Staden's Method: when f(b,l) = 0, replace with f(b,l) = 1/(n+t), t = %2.1f\n",
      niot);
    if (ricalctype == 'b') {
      fprintf(fout->f,
	"**************************************************************\n");
      fprintf(fout->f,
	"* WARNING: BUG version: Ri - Ehnb for cases where f(b,l) = 0 *\n");
      fprintf(fout->f,
	"**************************************************************\n");
    }
  } else if (ricalctype == 'l')
    fprintf(fout->f,
      "using Laplace's Method f(b,l) = (k+1)/(n+2) = (n(b,l)+1)/(n(l)+2)\n");
  else
    fprintf(fout->f, "%*.*f is the value of negative infinity\n",
	    infofield, infodecim, niot);

  fprintf(fout->f, "* \n");
  fprintf(fout->f, "* %c alignmenttype first, book, instructions\n",
	  alignmenttype);
}

/* Local variables for PatentMessage: */
struct LOC_PatentMessage {
  _TEXT *f;
} ;

Local Void makebar(LINK)
struct LOC_PatentMessage *LINK;
{
  fprintf(LINK->f->f,
    "**********************************************************************\n");
}

Static Void PatentMessage(f_)
_TEXT *f_;
{
  struct LOC_PatentMessage V;

  V.f = f_;
  makebar(&V);
  fprintf(V.f->f,
    "* By downloading this code you agree to the Source Code Use License: *\n");
  fprintf(V.f->f,
    "* https://alum.mit.edu/www/toms/Source_Code_Use_License.txt           *\n");
  fprintf(V.f->f,
    "* Contact: https://alum.mit.edu/www/toms/contacts.html                *\n");
  makebar(&V);
}

Static Void themain(inst, book, rsdata, values, rip, wave, rixyin, sequ, ribl)
_TEXT *inst, *book, *rsdata, *values, *rip, *wave, *rixyin, *sequ, *ribl;
{
  ribltype *matrix;
  double anticonsensus = 0.0;
  base b;
  double basestdev;
  long column;
  Char character;
  long columnindex;
  double consensus = 0.0;
  rstype data;
  boolean dontkillpartials;
  Char fromsign;
  long lengthanalyzed;
  double ln2 = log(2.0);
  double lowerRi, lowerValue, mean;
  long n = 0;
  double niot;
  Char ricalctype;
  long position;
  Char partials;
  boolean fullsite, printsequ, printrixyin;
  double Ritotal, stdev;
  double sumRi = 0.0, sumRi2 = 0.0;
  long thefrom, theto;
  Char tosign;
  double upperRi, upperValue, value;
  boolean valuesfull;
  long nl;
  double f, variance, sumVariance;
  piece *apiece;
  long length, alignedbase, fromparam, toparam;
  Char alignmenttype;
  long theline;
  _TEXT hold, TEMP;
  long FORLIM;

  hold.f = NULL;
  *hold.name = '\0';
  printf("Ri %4.2f\n", version);
  TEMP.f = stdout;
  *TEMP.name = '\0';
  PatentMessage(&TEMP);
  limitdate('9', '9', '9', '9', "    /99/99 99:99:99");

  apiece = (piece *)Malloc(sizeof(piece));

  brinit(book, &theline);
  if (*rixyin->name != '\0') {
    if (rixyin->f != NULL)
      rixyin->f = freopen(rixyin->name, "w", rixyin->f);
    else
      rixyin->f = fopen(rixyin->name, "w");
  } else {
    if (rixyin->f != NULL)
      rewind(rixyin->f);
    else
      rixyin->f = tmpfile();
  }
  if (rixyin->f == NULL)
    _EscIO2(FileNotFound, rixyin->name);
  SETUPBUF(rixyin->f, Char);

  fprintf(rixyin->f, "* bits\n");
  Riheader(rsdata, book, '*', rixyin);
  if (*ribl->name != '\0') {
    if (ribl->f != NULL)
      ribl->f = freopen(ribl->name, "w", ribl->f);
    else
      ribl->f = fopen(ribl->name, "w");
  } else {
    if (ribl->f != NULL)
      rewind(ribl->f);
    else
      ribl->f = tmpfile();
  }
  if (ribl->f == NULL)
    _EscIO2(FileNotFound, ribl->name);
  SETUPBUF(ribl->f, Char);
  if (*riinst.name != '\0') {
    if (riinst.f != NULL)
      riinst.f = freopen(riinst.name, "w", riinst.f);
    else
      riinst.f = fopen(riinst.name, "w");
  } else {
    if (riinst.f != NULL)
      rewind(riinst.f);
    else
      riinst.f = tmpfile();
  }
  if (riinst.f == NULL)
    _EscIO2(FileNotFound, riinst.name);
  SETUPBUF(riinst.f, Char);
  fprintf(riinst.f, "title \"WARNING: you need org and chr instructions\";\n");
  fprintf(riinst.f, "(* \n");
  Riheader(rsdata, book, '*', &riinst);
  fprintf(riinst.f, " *)\n\n");
  fprintf(riinst.f, "organism ORG; chromosome CHR;\n");

  matrix = (ribltype *)Malloc(sizeof(ribltype));

  readparameters(rip, &matrix->riblname, &thefrom, &theto, &column, &lowerRi,
		 &upperRi, &lowerValue, &upperValue, &printsequ, &printrixyin,
		 &partials, &niot, &ricalctype, &alignmenttype,
		 &matrix->Ribound, &matrix->Zbound, &matrix->Pbound);

  if (printsequ) {
    if (*sequ->name != '\0') {
      if (sequ->f != NULL)
	sequ->f = freopen(sequ->name, "w", sequ->f);
      else
	sequ->f = fopen(sequ->name, "w");
    } else {
      if (sequ->f != NULL)
	rewind(sequ->f);
      else
	sequ->f = tmpfile();
    }
    if (sequ->f == NULL)
      _EscIO2(FileNotFound, sequ->name);
    SETUPBUF(sequ->f, Char);
  }
  dontkillpartials = (partials != 'n');

  TEMP.f = stdout;
  *TEMP.name = '\0';
  writeparameters(&TEMP, thefrom, theto, column, lowerRi, upperRi, lowerValue,
		  upperValue, printsequ, printrixyin, partials, niot,
		  ricalctype, alignmenttype);
  writeparameters(rixyin, thefrom, theto, column, lowerRi, upperRi,
		  lowerValue, upperValue, printsequ, printrixyin, partials,
		  niot, ricalctype, alignmenttype);


  if (*hold.name != '\0') {
    if (hold.f != NULL)
      hold.f = freopen(hold.name, "w", hold.f);
    else
      hold.f = fopen(hold.name, "w");
  } else {
    if (hold.f != NULL)
      rewind(hold.f);
    else
      hold.f = tmpfile();
  }
  if (hold.f == NULL)
    _EscIO2(FileNotFound, hold.name);
  SETUPBUF(hold.f, Char);
  Riheader(rsdata, book, '*', &hold);
  writeparameters(&hold, thefrom, theto, column, lowerRi, upperRi, lowerValue,
		  upperValue, printsequ, printrixyin, partials, niot,
		  ricalctype, alignmenttype);
  fprintf(hold.f, "* %*s %*s %*s %*s %*c %*c %*c %*c %*c\n",
	  infofield, "Ri(a,l)", infofield, "Ri(c,l)", infofield, "Ri(g,l)",
	  infofield, "Ri(t,l)", nfield, 'l', nfield, 'a', nfield, 'c', nfield,
	  'g', nfield, 't');
  if (*hold.name != '\0') {
    if (hold.f != NULL)
      hold.f = freopen(hold.name, "r", hold.f);
    else
      hold.f = fopen(hold.name, "r");
  } else
    rewind(hold.f);
  if (hold.f == NULL)
    _EscIO2(FileNotFound, hold.name);
  RESETBUF(hold.f, Char);

  readheader(&hold, '*', &matrix->riblheader);

  fprintf(rixyin->f, "* Lengths file:\n");
  if (*values->name != '\0') {
    if (values->f != NULL)
      values->f = freopen(values->name, "r", values->f);
    else
      values->f = fopen(values->name, "r");
  } else
    rewind(values->f);
  if (values->f == NULL)
    _EscIO2(FileNotFound, values->name);
  RESETBUF(values->f, Char);
  if (BUFEOF(values->f)) {
    fprintf(rixyin->f, "* empty\n");
    valuesfull = false;
    value = 0.0;
  } else {
    while (P_peek(values->f) == '*')
      copyaline(values, rixyin);
    valuesfull = true;
  }
  fprintf(rixyin->f, "*\n");


  if (BUFEOF(rsdata->f)) {
    printf("empty rsdata file\n");
    halt();
  }


  if (*rsdata->name != '\0') {
    if (rsdata->f != NULL)
      rsdata->f = freopen(rsdata->name, "r", rsdata->f);
    else
      rsdata->f = fopen(rsdata->name, "r");
  } else
    rewind(rsdata->f);
  if (rsdata->f == NULL)
    _EscIO2(FileNotFound, rsdata->name);
  RESETBUF(rsdata->f, Char);
  readrsrange(rsdata, &data);

  if (data.rstop > maxribl) {
    printf(" From-range of site %ld exceeds maxribl %ld\n",
	   data.rstop, (long)maxribl);
    halt();
  }

  if (data.rstart < minribl) {
    printf(" To-range of site %ld exceeds minribl %ld\n",
	   data.rstart, (long)minribl);
    halt();
  }

  getrsbegin(rsdata);
  maxminalignment(inst, book, &theline, &fromparam, &toparam, alignmenttype);
  fprintf(rixyin->f, "* data are from %ld to %ld\n", data.rstart, data.rstop);
  fprintf(rixyin->f, "* book/inst alignment is from %ld to %ld\n",
	  fromparam, toparam);
  fprintf(rixyin->f, "* Ri analysis is from %ld to %ld\n", thefrom, theto);

  if (alignmenttype != 'f') {
    if (fromparam > thefrom) {
      printf(" Aligned FROM = %ld > requested FROM = %ld\n",
	     fromparam, thefrom);
      halt();
    }
  }

  if (data.rstart > thefrom) {
    printf(" In file rsdata the FROM = %ld > requested FROM = %ld\n",
	   data.rstart, thefrom);
    halt();
  }

  if (alignmenttype != 'f') {
    if (toparam < theto) {
      printf(" Aligned TO = %ld > requested TO = %ld\n", toparam, theto);
      halt();
    }
  }

  if (data.rstop < theto) {
    printf(" In file rsdata the TO = %ld > requested TO = %ld\n",
	   data.rstop, theto);
    halt();
  }
  getrsbegin(rsdata);
  matrix->frombase = thefrom;
  matrix->tobase = theto;

  FORLIM = data.rstop;
  for (position = data.rstart; position <= FORLIM; position++) {
    if (P_peek(rsdata->f) != '*') {
      readrsdata(rsdata, &data);
      if (position != data.l)
	printf("Warning: position should be %ld, but is actually %ld\n",
	       position, data.l);

      if (position >= thefrom && position <= theto) {
	matrix->data[0][data.l - minribl] = Ricalc(data.ehnb, data.nal,
						   data.nl, niot, ricalctype);
	matrix->data[(long)c - (long)a]
	  [data.l - minribl] = Ricalc(data.ehnb, data.ncl, data.nl, niot,
				      ricalctype);
	matrix->data[(long)g - (long)a]
	  [data.l - minribl] = Ricalc(data.ehnb, data.ngl, data.nl, niot,
				      ricalctype);
	matrix->data[(long)t - (long)a]
	  [data.l - minribl] = Ricalc(data.ehnb, data.ntl, data.nl, niot,
				      ricalctype);
	matrix->numbers[0][data.l - minribl] = data.nal;
	matrix->numbers[(long)c - (long)a][data.l - minribl] = data.ncl;
	matrix->numbers[(long)g - (long)a][data.l - minribl] = data.ngl;
	matrix->numbers[(long)t - (long)a][data.l - minribl] = data.ntl;

	consensus =
	  max(max(max(matrix->data[0]
		      [data.l - minribl], matrix->data[(long)c - (long)a]
		      [data.l - minribl]), matrix->data[(long)g - (long)a]
		  [data.l - minribl]), matrix->data[(long)t - (long)a]
	      [data.l - minribl]) + consensus;

	anticonsensus =
	  min(min(min(matrix->data[0]
		      [data.l - minribl], matrix->data[(long)c - (long)a]
		      [data.l - minribl]), matrix->data[(long)g - (long)a]
		  [data.l - minribl]), matrix->data[(long)t - (long)a]
	      [data.l - minribl]) + anticonsensus;
      }
    }
  }

  fprintf(rixyin->f, "*\n");
  fprintf(rixyin->f, "* Columns:\n");
  fprintf(rixyin->f, "*  1 piece number\n");
  fprintf(rixyin->f, "*  2 piece name\n");
  fprintf(rixyin->f, "*  3 sequence region analyzed (if printed, - if not)\n");
  fprintf(rixyin->f, "*  4 length of region analyzed on this piece \n");
  fprintf(rixyin->f, "*  5 aligning coordinate on piece\n");
  fprintf(rixyin->f, "*  6 Rindividual for the piece\n");
  fprintf(rixyin->f, "*  7 value from the values file\n");
  fprintf(rixyin->f,
	  "*  8 standard deviation of Rindividual for that sequence\n");
  fprintf(rixyin->f, "*\n");

  while (!BUFEOF(book->f)) {
    switch (alignmenttype) {
    case 'i':
      align(inst, book, &theline, &apiece, &length, &alignedbase);
      break;
    case 'b':
    case 'f':
      getpiece(book, &theline, &apiece);
      length = piecelength(apiece);
      break;
    }

    if (BUFEOF(book->f))
      break;
    n++;

    switch (alignmenttype) {
    case 'f':
      alignedbase = 1;
      break;
    case 'i':
      break;
    case 'b':
      alignedbase = pietoint(0L, apiece);
      break;
    }

    Ritotal = 0.0;
    sumVariance = 0.0;
    fullsite = true;
    for (position = thefrom; position <= theto; position++) {
      if (withinalignment(position, alignedbase, length)) {
	b = getbase(position + alignedbase, apiece);
	Ritotal += matrix->data[(long)b - (long)a][position - minribl];
	nl = matrix->numbers[0]
	     [position - minribl] + matrix->numbers[(long)c - (long)a]
	     [position - minribl] + matrix->numbers[(long)g - (long)a]
	     [position - minribl] + matrix->numbers[(long)t - (long)a]
	     [position - minribl];
	if (matrix->numbers[(long)b - (long)a][position - minribl] == 0)
	  f = 1.0 / (nl + 2);
	else
	  f = (double)matrix->numbers[(long)b - (long)a][position - minribl] / nl;
	variance = (1 - f) / f / nl;
	sumVariance += variance;

      } else
	fullsite = false;
    }

    if (valuesfull) {
      if (!BUFEOF(values->f)) {
	while (P_peek(values->f) == '*') {
	  fscanf(values->f, "%*[^\n]");
	  getc(values->f);
	}
	columnindex = 1;
	while (columnindex < column) {
	  skipblanks(values);
	  skipnonblanks(values);
	  columnindex++;
	}
	if (P_eoln(values->f)) {
	  printf("Missing data column %ld in values file\n", column);
	  halt();
	}
	fscanf(values->f, "%lg%*[^\n]", &value);
	getc(values->f);
      } else {
	value = 0.0;
	printf("Note: A zero was inserted into the rixyin file value column");
	if (numbered)
	  printf(" for piece number %ld\n", number);
	else
	  putchar('\n');
	printf("because the values file has finished.\n");
      }
    }

    if (Ritotal >= lowerRi && Ritotal <= upperRi &&
	(fullsite || dontkillpartials)) {
      if (value >= lowerValue && value <= upperValue) {
	sumRi += Ritotal;
	sumRi2 += Ritotal * Ritotal;

	if (numbered)
	  fprintf(rixyin->f, " %6ld ", number);
	else
	  fprintf(rixyin->f, " (no.#) ");

	fprintf(rixyin->f, " %.*s",
		namelength, apiece->key.hea.keynam.letters);


	if (printrixyin)
	  putc(' ', rixyin->f);
	else
	  fprintf(rixyin->f, " -");

	lengthanalyzed = 0;
	for (position = thefrom; position <= theto; position++) {
	  if (withinalignment(position, alignedbase, length)) {
	    character = basetochar(getbase(position + alignedbase, apiece));
	    if (printsequ)
	      putc(character, sequ->f);
	    if (printrixyin)
	      putc(character, rixyin->f);
	    lengthanalyzed++;
	  } else if (printrixyin)
	    putc('-', rixyin->f);
	}
	if (printsequ)
	  fprintf(sequ->f, ".\n");

	fprintf(rixyin->f, " %*ld", nfield, lengthanalyzed);
	fprintf(rixyin->f, " %*ld", nfield, inttopie(alignedbase, apiece));

	if (fullsite || partials != 'i') {
	  fprintf(rixyin->f, " %*.*f", infofield, infodecim, Ritotal);
	} else
	  fprintf(rixyin->f, " %*ld", infofield, (long)defnegativeinfinity);

	fprintf(rixyin->f, " %*.*f", infofield, infodecim, value);

	fprintf(rixyin->f, " %*.*f\n",
		infofield, infodecim, sumVariance * sumVariance);

/* p2c: ri.p, line 4073: Note:
 * Format for packed-array-of-char will work only if width < length [321] */
	fprintf(riinst.f, "piece %.*s;",
		apiece->key.hea.keynam.length,
		apiece->key.hea.keynam.letters);
	fprintf(riinst.f, " get from ");
	fprintf(riinst.f, "%ld", inttopie(alignedbase, apiece));

	switch (apiece->key.piedir) {
	case minus:
	  fromsign = '+';
	  tosign = '-';
	  break;
	case plus:
	  fromsign = '-';
	  tosign = '+';
	  break;
	}

	fprintf(riinst.f, " %cFROM to same %cTO direction %c",
		fromsign, tosign, tosign);

	fprintf(riinst.f, "; (* %1.*f bits *)\n", infodecim, Ritotal);
      }
    }
    clearpiece(&apiece);
  }

  if (n == 0) {
    printf("NO SEQUENCES FOUND IN BOOK!\n");
    if (*ribl->name != '\0') {
      if (ribl->f != NULL)
	ribl->f = freopen(ribl->name, "w", ribl->f);
      else
	ribl->f = fopen(ribl->name, "w");
    } else {
      if (ribl->f != NULL)
	rewind(ribl->f);
      else
	ribl->f = tmpfile();
    }
    if (ribl->f == NULL)
      _EscIO2(FileNotFound, ribl->name);
    SETUPBUF(ribl->f, Char);
    halt();
  }

  if (n == 1) {
    printf("ONLY ONE SEQUENCE FOUND IN BOOK!\n");
    if (*ribl->name != '\0') {
      if (ribl->f != NULL)
	ribl->f = freopen(ribl->name, "w", ribl->f);
      else
	ribl->f = fopen(ribl->name, "w");
    } else {
      if (ribl->f != NULL)
	rewind(ribl->f);
      else
	ribl->f = tmpfile();
    }
    if (ribl->f == NULL)
      _EscIO2(FileNotFound, ribl->name);
    SETUPBUF(ribl->f, Char);
    halt();
  }

  if (n == 2) {
    printf("ONLY TWO SEQUENCES FOUND IN BOOK!\n");
    if (*ribl->name != '\0') {
      if (ribl->f != NULL)
	ribl->f = freopen(ribl->name, "w", ribl->f);
      else
	ribl->f = fopen(ribl->name, "w");
    } else {
      if (ribl->f != NULL)
	rewind(ribl->f);
      else
	ribl->f = tmpfile();
    }
    if (ribl->f == NULL)
      _EscIO2(FileNotFound, ribl->name);
    SETUPBUF(ribl->f, Char);
    halt();
  }

  mean = sumRi / n;
  basestdev = sumRi2 / n - mean * mean;

  if (basestdev > 0)
    stdev = sqrt(n / (n - 1.0)) * sqrt(sumRi2 / n - mean * mean);
  else
    stdev = 0.0;

  matrix->mean = mean;
  matrix->stdev = stdev;
  matrix->consensus = consensus;
  matrix->anticonsensus = anticonsensus;
  matrix->averageRi = computerandomav(matrix->data, thefrom, theto);
  matrix->n = n;
  matrix->symmetry = matrixsymmetry(matrix->data, thefrom, theto);

  if (*wave->name != '\0') {
    if (wave->f != NULL)
      wave->f = freopen(wave->name, "r", wave->f);
    else
      wave->f = fopen(wave->name, "r");
  } else
    rewind(wave->f);
  if (wave->f == NULL)
    _EscIO2(FileNotFound, wave->name);
  RESETBUF(wave->f, Char);
  readwaveparameters(wave, &matrix->waves);

  switch (matrix->symmetry) {
  case 'a':
    printf("asymmetric");
    break;
  case 'e':
    printf("even");
    break;
  case 'o':
    printf("odd");
    break;
  }
  printf(" symmetry of the matrix\n");

  putriblmatrix(ribl, matrix);
  if (hold.f != NULL)
    fclose(hold.f);
}


/* Print help for user */
void usage() {
  printf("\n");
  printf("   ri: Rindividual is calculated for every site in the aligned book\n");
  printf("\n   ri -b myBook.txt -i instructions.txt -r rsdata -v values -o output_book -p riParameterFile -w wave \n\n");
  printf("  -b delila book \n");
  printf("  -i Instruction file: instructions written in the language delila that tell the\n");
  printf("     program delila what sequences to pull out of the library.\n");
  printf("  -r data file from rseq program\n");
  printf("  -v file containing the values of the objects to which the Ri values are to be \n");
  printf("     compared.  The file may be empty. \n");
  printf("  -o riinst, output name for Delila instructions for the selected subset of sites.\n");
  printf("  -p Parameters file to control the program for details see: \n");
  printf("     http://users.fred.net/tds/lab/delila/ri.html\n");
  printf("  -w wave file, Define a cosine wave.");
  printf("\n");
  printf("  version %2.2f\n", version);
  exit(EXIT_SUCCESS);
}

int main(int argc, Char **argv) 
{
  extern char *optarg;
	extern int optind;
	int c, err = 0; 
  /* flags marking arguments passed */
  int bflag=0;       /* delila book input file flag */
	int iflag=0;       /* delila instructions file flag */
  int rflag=0;       /* rsdata file flag */
  int vflag=0;       /* values input file flag */
  int oflag=0;       /* ri output instructions flag */
  int pflag=0;       /* ri parameter file flag */
  int wflag=0;       /* wave input file flag */
	char *bookName = "book.txt";
  char *instructions = "instructions.txt";
  char *data = "rsdata.txt";
  char *val  = "values.txt";
  char *param = "riParameter.txt";
  char *wv    = "wave.txt";
  char *out   = "ri_out_inst.txt";

/* Process command line arguments  */
while ((c = getopt(argc, argv, "b:i:r:v:p:w:o")) != -1)
		switch (c) {
		case 'b':
      bflag = 1;
			bookName = optarg;
			break;
		case 'i':
      iflag = 1;
			instructions = optarg;
			break;
		case 'r':
      rflag = 1;
			data = optarg;
			break;
    case 'v':
      vflag = 1;
      val = optarg;
      break;
    case 'p':
      pflag = 1;
      param = optarg;
      break;
    case 'w':
      wflag = 1;
      wv = optarg;
      break; 
    case 'o':
      oflag = 1;
      out = optarg;
      break;      
		case '?':
			err = 1;
			break;
		}

  /* Is the book file name present */  
	if (bflag == 0) {	/* -b bookname was mandatory */ 
		fprintf(stderr, "%s: missing -b bookname\n", argv[0]);
		usage();
		exit(1);
	} 

  /* Instruction file ? */
  if (iflag == 0) { /* -i was mandatory */        
		fprintf(stderr, "%s: missing -i instruction file\n", argv[0]);
		usage();
		exit(1);
  } 

  /* rsdata file name  */  
  if (rflag == 0) { 
    fprintf(stderr, "%s: missing -r rsdata file name \n", argv[0]);
		usage();
		exit(1);
    } 

  /* ri parameter file name  */  
  if (pflag == 0) { 
    fprintf(stderr, "%s: missing -p ri parameter file name \n", argv[0]);
		usage();
		exit(1);
    } 

  /* values file name  */  
  if (vflag == 0) { 
    fprintf(stderr, "%s: missing -v values file name \n", argv[0]);
		usage();
		exit(1);
    } 

  /* wave file name  */  
  if (wflag == 0) { 
    fprintf(stderr, "%s: missing -w wave file name \n", argv[0]);
		usage();
		exit(1);
    } 
  /* ri out instructions file name  */  
  if (oflag == 0) { 
    fprintf(stderr, "%s: missing -o ri instructions out file name \n", argv[0]);
		usage();
		exit(1);
    } 

  if (err) {
		usage();
		exit(1);
	}
  PASCAL_MAIN(argc, argv);
  if (setjmp(_JL1))
    goto _L1;
  riinst.f = NULL;
  strcpy(riinst.name, instructions);
  ribl.f = NULL;
  strcpy(ribl.name, "ribl");
  sequ.f = NULL;
  strcpy(sequ.name, "sequ");
  rixyin.f = NULL;
  strcpy(rixyin.name, "rixyin");
  wave.f = NULL;
  strcpy(wave.name, wv);
  rip.f = NULL;
  strcpy(rip.name, param);
  values.f = NULL;
  strcpy(values.name, val);
  rsdata.f = NULL;
  strcpy(rsdata.name, data);
  book.f = NULL;
  strcpy(book.name, bookName);
  inst.f = NULL;
  strcpy(inst.name, out);
  themain(&inst, &book, &rsdata, &values, &rip, &wave, &rixyin, &sequ, &ribl);
_L1:
  if (inst.f != NULL)
    fclose(inst.f);
  if (book.f != NULL)
    fclose(book.f);
  if (rsdata.f != NULL)
    fclose(rsdata.f);
  if (values.f != NULL)
    fclose(values.f);
  if (rip.f != NULL)
    fclose(rip.f);
  if (wave.f != NULL)
    fclose(wave.f);
  if (rixyin.f != NULL)
    fclose(rixyin.f);
  if (sequ.f != NULL)
    fclose(sequ.f);
  if (ribl.f != NULL)
    fclose(ribl.f);
  if (riinst.f != NULL)
    fclose(riinst.f);
  exit(EXIT_SUCCESS);
return 0;
}
/* End. */