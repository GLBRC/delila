/* Output from p2c 2.00.Oct.15, the Pascal-to-C translator */
/* From input file "pbreak.p" */


 #include "/root/src/p2c-2.01/home/src/p2c.h"


/*

*/



#define version         4.26
/*



*/



/*

































































*/


#define top             170
#define pagewidth       90
/*




*/
#define pagelength      54

#define liston          false
#define debug           false


typedef struct buffer {
  Char place[top];
  long length, pagenumber;
  /*
*/
  struct buffer *next;
} buffer;


Static _TEXT list, pbreakp;

Static buffer *first, *trigger;

Static boolean trigerinbuffer;

Static long numbpgs;

Static long rightbound;


Static jmp_buf _JL1;


Static Void halt()
{
  /*





*/
  printf(" program halt.\n");
  longjmp(_JL1, 1);
}



Static Void firstpage(afile)
_TEXT *afile;
{
  /*

*/
  /*





*/

  fprintf(afile->f,
	  "%% LaTeX input, generated by version = %4.2f of pbreak\n",
	  version);
  fprintf(afile->f, "\\documentstyle{article}\n");
  fprintf(afile->f, "\\begin{document}\n");
  fprintf(afile->f, "%%\\footnotesize\n");
  fprintf(afile->f, "\\textheight 9in\n");
  fprintf(afile->f,
	  "\\topmargin -0.25in %% -0.5 would shift the whole thing up\n");
  fprintf(afile->f, "\\headheight 0in\n");
  fprintf(afile->f, "\\headsep 0in\n");
  fprintf(afile->f, "\\textwidth 7in\n");
  fprintf(afile->f,
	  "\\hsize=9in %% make TeX shut up about overfull \\hboxes!!!\n");
  fprintf(afile->f, "\\oddsidemargin 0.0in %% -0.5 shifts left\n");
  fprintf(afile->f, "\\begin{verbatim}\n");

}



Static Void makepage(afile)
_TEXT *afile;
{
  /*

*/
  /*

*/


  fprintf(afile->f, "\\end{verbatim}\n");
  fprintf(afile->f, "\\pagebreak\n");
  fprintf(afile->f, "\\begin{verbatim}\n");

}



Static Void lastpage(afile)
_TEXT *afile;
{
  fprintf(afile->f, "\\end{verbatim}\n");
  fprintf(afile->f, "\\end{document}\n");

}


Static Void readintobuffer(fin, b)
_TEXT *fin;
buffer **b;
{
  long i = 0;

  (*b)->length = 0;

  while ((i < top) & (!(P_eoln(fin->f) | BUFEOF(fin->f)))) {
    i++;
    (*b)->place[i-1] = getc(fin->f);
    if ((*b)->place[i-1] == '\n')
      (*b)->place[i-1] = ' ';
    (*b)->length = i;
  }

  if (i == top) {
    if (!P_eoln(fin->f)) {
      fprintf(list.f, " line longer than %ld\n", (long)top);
      halt();
    }
  }
  (*b)->pagenumber = 0;
  (*b)->next = NULL;
  if (!BUFEOF(fin->f)) {
    fscanf(fin->f, "%*[^\n]");
    getc(fin->f);
  }

}


Static Void lookfortrigger(trigger, b, trigerinbuffer)
buffer *trigger, *b;
boolean *trigerinbuffer;
{
  /*
*/
  long d = 1, i = 1, level = 0;


  while (level < trigger->length && i <= b->length) {
    if (b->place[i-1] == trigger->place[d-1]) {
      /*
*/
      level++;
      i++;
      d++;
      continue;
    }
    if (b->place[i-1] == trigger->place[0]) {
      level = 0;
      d = 1;
      continue;
    }



    level = 0;
    d = 1;
    i++;
    if (i > rightbound) {
      i = b->length + 1;


    }
  }
  if (level == trigger->length)
    *trigerinbuffer = true;
  else
    *trigerinbuffer = false;
}


Static Void writebuffer(fout, b)
_TEXT *fout;
buffer *b;
{

  /*
*/
  long i = 0;
  long c, FORLIM;

  FORLIM = b->length;
  for (c = 1; c <= FORLIM; c++) {
    i++;
    putc(b->place[i-1], fout->f);
  }
}


Static Void writetrigger(fout, b)
_TEXT *fout;
buffer *b;
{
  long i = 0;
  long c, FORLIM;

  fprintf(fout->f, " '");
  FORLIM = b->length;
  for (c = 1; c <= FORLIM; c++) {
    i++;
    putc(b->place[i-1], fout->f);
  }
  fprintf(fout->f, "'\n");
}


Static Void removeblanks(b)
buffer **b;
{
  buffer *WITH;

  WITH = *b;
  if (WITH->length <= 0)
    return;
  if (WITH->place[WITH->length - 1] == ' ') {
    while (WITH->place[WITH->length - 1] == ' ' && WITH->length != 1)
      WITH->length--;
  }
}


Static Void checktrigger()
{
  /*
*/
  if (trigger->length <= 0) {
    fprintf(list.f, "  trigger is blank.\n");
    halt();
  }
}


Static boolean afteryou(p)
buffer *p;
{
  /*
*/
  boolean Result;
  long n = 1;
  boolean done = false;

  while (!done) {
    if (p->next == NULL)
      break;
/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
    if (p->place[n-1] < p->next->place[n-1]) {
      break;
/* p2c: pbreak.p: Note: Deleting unreachable code [255] */
    }

/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
    if (p->place[n-1] > p->next->place[n-1]) {
      break;
/* p2c: pbreak.p: Note: Deleting unreachable code [255] */
    }

/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
    if (n == p->length && n < p->next->length) {
      break;
/* p2c: pbreak.p: Note: Deleting unreachable code [255] */
    }
/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
    if (n == p->next->length && n < p->length) {
      break;
/* p2c: pbreak.p: Note: Deleting unreachable code [255] */
    }
/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
    if (n != p->length || n != p->next->length) {
/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
      n++;
      continue;
    }
    /*
*/
    if (p->pagenumber > p->next->pagenumber) {
      Result = true;
      done = true;
    } else {
      Result = false;
      done = true;
    }
  }
  return Result;

  /*
*/
  /*
*/
/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
/* p2c: pbreak.p: Note: Eliminated unused assignment statement [338] */
}


Static Void putinlist(first, current)
buffer **first, **current;
{
  /*

*/
  buffer *lookptr;

  lookptr = *first;
  (*current)->next = *first;
  if (!afteryou(*current)) {
    *first = *current;
    /*
*/
    return;
  }
  (*current)->next = (*first)->next;
  while (afteryou(*current)) {
    lookptr = lookptr->next;
    (*current)->next = (*current)->next->next;
  }

  lookptr->next = *current;
}


#define numfield        4


Static Void listout(place, first)
_TEXT *place;
buffer *first;
{
  /*

*/
  /*
*/

  long i;
  long linenumb = 0;
  buffer *listptr = first;
  long FORLIM;

  while (listptr != NULL) {
    if (linenumb % pagelength == 0) {
      makepage(place);


      FORLIM = (long)floor(pagewidth / 2.0 + 0.5) - 3;
      for (i = 1; i <= FORLIM; i++)
	putc(' ', place->f);
      fprintf(place->f, "index\n\n\n");


      for (i = 1; i <= 5; i++)
	putc(' ', place->f);
      fprintf(place->f, "page title");
      for (i = 16; i <= pagewidth - 12; i++)
	putc(' ', place->f);
      fprintf(place->f, "page number\n");


      for (i = 1; i <= 5; i++)
	putc(' ', place->f);
      for (i = 6; i <= 15; i++)
	putc('-', place->f);
      for (i = 16; i <= pagewidth - 12; i++)
	putc(' ', place->f);
      for (i = pagewidth - 11; i < pagewidth; i++)
	putc('-', place->f);
      putc('\n', place->f);
      linenumb += 6;
    }

    if (debug)
      fprintf(place->f, " listptr^.length is:%4ld\n", listptr->length);
    removeblanks(&listptr);
    putc(' ', place->f);
    if (listptr->length <= pagewidth - numfield - 5) {
      writebuffer(place, listptr);
      putc(' ', place->f);
      for (i = listptr->length + 2; i <= pagewidth - numfield - 3; i++)
	putc('.', place->f);
      putc(' ', place->f);
      fprintf(place->f, "%*ld\n", numfield, listptr->pagenumber);
    }

    else {
      listptr->length = pagewidth - numfield - 4;
      /*
*/

      writebuffer(place, listptr);
      putc('/', place->f);
      putc(' ', place->f);
      fprintf(place->f, "%*ld\n", numfield, listptr->pagenumber);
    }
    listptr = listptr->next;
    if (debug)
      fprintf(place->f, " went to listptr^.next:\n");
    linenumb++;
  }
}

#undef numfield


Static Void doit(fin, fout)
_TEXT *fin, *fout;
{
  buffer *current;
  long i;
  long linenumber = 0;

  numbpgs = 0;
  current = (buffer *)Malloc(sizeof(buffer));
  first = NULL;

  while (!BUFEOF(fin->f)) {
    readintobuffer(fin, &current);
    linenumber++;

    lookfortrigger(trigger, current, &trigerinbuffer);

    if (!(trigerinbuffer || linenumber > pagelength)) {
      writebuffer(fout, current);
      putc('\n', fout->f);
      continue;
    }
    if (numbpgs == 0)
      firstpage(fout);
    else
      makepage(fout);
    linenumber = 1;
    numbpgs++;


    current->pagenumber = numbpgs;
    if (current->length <= pagewidth - 7) {
      writebuffer(fout, current);
      for (i = current->length; i <= pagewidth - 7; i++)
	putc(' ', fout->f);
      fprintf(fout->f, "%5ld\n", current->pagenumber);
    }

    else {
      writebuffer(fout, current);
      putc('\n', fout->f);
    }



    if (trigerinbuffer) {
      putinlist(&first, &current);
      current = (buffer *)Malloc(sizeof(buffer));
    }
  }


  fprintf(list.f, " number of pages added: %3ld\n", numbpgs);
  if (liston)
    listout(&list, first);
  listout(fout, first);

  lastpage(fout);
}


Static Void themain(pbreakp, fin, fout, list)
_TEXT *pbreakp, *fin, *fout, *list;
{
  if (*list->name != '\0') {
    if (list->f != NULL)
      list->f = freopen(list->name, "w", list->f);
    else
      list->f = fopen(list->name, "w");
  } else {
    if (list->f != NULL)
      rewind(list->f);
    else
      list->f = tmpfile();
  }
  if (list->f == NULL)
    _EscIO2(FileNotFound, list->name);
  SETUPBUF(list->f, Char);
  fprintf(list->f, " pbreak %4.2f   breaks files into pages.\n", version);
  if (*pbreakp->name != '\0') {
    if (pbreakp->f != NULL)
      pbreakp->f = freopen(pbreakp->name, "r", pbreakp->f);
    else
      pbreakp->f = fopen(pbreakp->name, "r");
  } else
    rewind(pbreakp->f);
  if (pbreakp->f == NULL)
    _EscIO2(FileNotFound, pbreakp->name);
  RESETBUF(pbreakp->f, Char);

  trigger = (buffer *)Malloc(sizeof(buffer));
  readintobuffer(pbreakp, &trigger);
  checktrigger();
  removeblanks(&trigger);

  fprintf(list->f, "\n trigger length is: ");
  fprintf(list->f, "%3ld\n", trigger->length);
  fprintf(list->f, " the trigger used is:  ");
  writetrigger(list, trigger);
  putc('\n', list->f);

  if (BUFEOF(pbreakp->f)) {
    rightbound = LONG_MAX;
    fprintf(list->f, " triggers will be detected anywhere in the file\n");
  } else {
    fscanf(pbreakp->f, "%ld%*[^\n]", &rightbound);
    getc(pbreakp->f);
    if (rightbound < 1) {
      fprintf(list->f, " right boundary for trigger must be positive\n");
      halt();
    }
    fprintf(list->f,
      " triggers will not be detected to the right of character column %ld\n",
      rightbound);
  }
  putc('\n', list->f);

  /*





*/

  doit(fin, fout);
}


main(argc, argv)
int argc;
Char *argv[];
{
  _TEXT TEMP, TEMP1;

  PASCAL_MAIN(argc, argv);
  if (setjmp(_JL1))
    goto _L1;
  pbreakp.f = NULL;
  strcpy(pbreakp.name, "pbreakp");
  list.f = NULL;
  strcpy(list.name, "list");
  TEMP.f = stdin;
  *TEMP.name = '\0';
  TEMP1.f = stdout;
  *TEMP1.name = '\0';
  themain(&pbreakp, &TEMP, &TEMP1, &list);
_L1:
  if (list.f != NULL)
    fclose(list.f);
  if (pbreakp.f != NULL)
    fclose(pbreakp.f);
  exit(EXIT_SUCCESS);
}



/* End. */
